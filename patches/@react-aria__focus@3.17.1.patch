diff --git a/dist/FocusScope.main.js b/dist/FocusScope.main.js
index 8bbb1fbd360453681f81314ad0bd7d14b7f5e718..ff67199a095f73a1de7eb77ce3e5402fe2d3f2b8 100644
--- a/dist/FocusScope.main.js
+++ b/dist/FocusScope.main.js
@@ -33,6 +33,7 @@ $parcel$export(module.exports, "createFocusManager", () => $a7a032acae3ddda9$exp
 
 
 const $a7a032acae3ddda9$var$FocusContext = /*#__PURE__*/ (0, ($parcel$interopDefault($euGna$react))).createContext(null);
+const $a7a032acae3ddda9$var$RESTORE_FOCUS_EVENT = 'react-aria-focus-scope-restore';
 let $a7a032acae3ddda9$var$activeScope = null;
 function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
     let { children: children, contain: contain, restoreFocus: restoreFocus, autoFocus: autoFocus } = props;
@@ -74,11 +75,17 @@ function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
         // Find all rendered nodes between the sentinels and add them to the scope.
         let node = (_startRef_current = startRef.current) === null || _startRef_current === void 0 ? void 0 : _startRef_current.nextSibling;
         let nodes = [];
+        let stopPropagation = (e)=>e.stopPropagation();
         while(node && node !== endRef.current){
             nodes.push(node);
+            // Stop custom restore focus event from propagating to parent focus scopes.
+            node.addEventListener($a7a032acae3ddda9$var$RESTORE_FOCUS_EVENT, stopPropagation);
             node = node.nextSibling;
         }
         scopeRef.current = nodes;
+        return ()=>{
+            for (let node of nodes)node.removeEventListener($a7a032acae3ddda9$var$RESTORE_FOCUS_EVENT, stopPropagation);
+        };
     }, [
         children
     ]);
@@ -89,7 +96,8 @@ function $a7a032acae3ddda9$export$20e40289641fbbb6(props) {
     // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.
     // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.
     (0, $euGna$react.useEffect)(()=>{
-        const activeElement = (0, $euGna$reactariautils.getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined).activeElement;
+        var _getRootNode;
+        const activeElement = (_getRootNode = (0, $euGna$reactariautils.getRootNode)(scopeRef.current ? scopeRef.current[0] : undefined)) === null || _getRootNode === void 0 ? void 0 : _getRootNode.activeElement;
         let scope = null;
         if ($a7a032acae3ddda9$var$isElementInScope(activeElement, scopeRef.current)) {
             // We need to traverse the focusScope tree and find the bottom most scope that
@@ -141,9 +149,10 @@ function $a7a032acae3ddda9$export$10c5169755ce7bd7() {
 function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
     return {
         focusNext (opts = {}) {
+            var _getRootNode;
             let scope = scopeRef.current;
             let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;
-            let node = from || (0, $euGna$reactariautils.getOwnerDocument)(scope[0]).activeElement;
+            let node = from || ((_getRootNode = (0, $euGna$reactariautils.getRootNode)(scope[0])) === null || _getRootNode === void 0 ? void 0 : _getRootNode.activeElement);
             let sentinel = scope[0].previousElementSibling;
             let scopeRoot = $a7a032acae3ddda9$var$getScopeRoot(scope);
             let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(scopeRoot, {
@@ -160,9 +169,10 @@ function $a7a032acae3ddda9$var$createFocusManagerForScope(scopeRef) {
             return nextNode;
         },
         focusPrevious (opts = {}) {
+            var _getRootNode;
             let scope = scopeRef.current;
             let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;
-            let node = from || (0, $euGna$reactariautils.getOwnerDocument)(scope[0]).activeElement;
+            let node = from || ((_getRootNode = (0, $euGna$reactariautils.getRootNode)(scope[0])) === null || _getRootNode === void 0 ? void 0 : _getRootNode.activeElement);
             let sentinel = scope[scope.length - 1].nextElementSibling;
             let scopeRoot = $a7a032acae3ddda9$var$getScopeRoot(scope);
             let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(scopeRoot, {
@@ -239,8 +249,8 @@ function $a7a032acae3ddda9$var$shouldContainFocus(scopeRef) {
     return true;
 }
 function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
-    let focusedNode = (0, $euGna$react.useRef)();
-    let raf = (0, $euGna$react.useRef)();
+    let focusedNode = (0, $euGna$react.useRef)(undefined);
+    let raf = (0, $euGna$react.useRef)(undefined);
     (0, $euGna$reactariautils.useLayoutEffect)(()=>{
         let scope = scopeRef.current;
         if (!contain) {
@@ -251,7 +261,7 @@ function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
             }
             return;
         }
-        const ownerDocument = (0, $euGna$reactariautils.getOwnerDocument)(scope ? scope[0] : undefined);
+        const ownerDocument = (0, $euGna$reactariautils.getRootNode)(scope ? scope[0] : undefined) || (0, $euGna$reactariautils.getOwnerDocument)(scope ? scope[0] : undefined);
         // Handle the Tab key to contain focus within the scope
         let onKeyDown = (e)=>{
             if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !$a7a032acae3ddda9$var$shouldContainFocus(scopeRef) || e.isComposing) return;
@@ -292,7 +302,7 @@ function $a7a032acae3ddda9$var$useFocusContainment(scopeRef, contain) {
                 // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                 if (ownerDocument.activeElement && $a7a032acae3ddda9$var$shouldContainFocus(scopeRef) && !$a7a032acae3ddda9$var$isElementInChildScope(ownerDocument.activeElement, scopeRef)) {
                     $a7a032acae3ddda9$var$activeScope = scopeRef;
-                    if (ownerDocument.body.contains(e.target)) {
+                    if ((0, $euGna$reactariautils.getRootBody)(ownerDocument).contains(e.target)) {
                         var _focusedNode_current;
                         focusedNode.current = e.target;
                         (_focusedNode_current = focusedNode.current) === null || _focusedNode_current === void 0 ? void 0 : _focusedNode_current.focus();
@@ -366,7 +376,7 @@ function $a7a032acae3ddda9$var$focusElement(element, scroll = false) {
     // ignore
     }
 }
-function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
+function $a7a032acae3ddda9$var$getFirstInScope(scope, tabbable = true) {
     let sentinel = scope[0].previousElementSibling;
     let scopeRoot = $a7a032acae3ddda9$var$getScopeRoot(scope);
     let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(scopeRoot, {
@@ -383,7 +393,10 @@ function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
         walker.currentNode = sentinel;
         nextNode = walker.nextNode();
     }
-    $a7a032acae3ddda9$var$focusElement(nextNode);
+    return nextNode;
+}
+function $a7a032acae3ddda9$var$focusFirstInScope(scope, tabbable = true) {
+    $a7a032acae3ddda9$var$focusElement($a7a032acae3ddda9$var$getFirstInScope(scope, tabbable));
 }
 function $a7a032acae3ddda9$var$useAutoFocus(scopeRef, autoFocus) {
     const autoFocusRef = (0, ($parcel$interopDefault($euGna$react))).useRef(autoFocus);
@@ -404,7 +417,7 @@ function $a7a032acae3ddda9$var$useActiveScopeTracker(scopeRef, restore, contain)
     (0, $euGna$reactariautils.useLayoutEffect)(()=>{
         if (restore || contain) return;
         let scope = scopeRef.current;
-        const ownerDocument = (0, $euGna$reactariautils.getOwnerDocument)(scope ? scope[0] : undefined);
+        const ownerDocument = (0, $euGna$reactariautils.getRootNode)(scope ? scope[0] : undefined) || (0, $euGna$reactariautils.getOwnerDocument)(scope ? scope[0] : undefined);
         let onFocus = (e)=>{
             let target = e.target;
             if ($a7a032acae3ddda9$var$isElementInScope(target, scopeRef.current)) $a7a032acae3ddda9$var$activeScope = scopeRef;
@@ -438,7 +451,7 @@ function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain)
     // restoring-non-containing scopes should only care if they become active so they can perform the restore
     (0, $euGna$reactariautils.useLayoutEffect)(()=>{
         let scope = scopeRef.current;
-        const ownerDocument = (0, $euGna$reactariautils.getOwnerDocument)(scope ? scope[0] : undefined);
+        const ownerDocument = (0, $euGna$reactariautils.getRootNode)(scope ? scope[0] : undefined) || (0, $euGna$reactariautils.getOwnerDocument)(scope ? scope[0] : undefined);
         if (!restoreFocus || contain) return;
         let onFocus = ()=>{
             // If focusing an element in a child scope of the currently active scope, the child becomes active.
@@ -457,7 +470,7 @@ function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain)
         contain
     ]);
     (0, $euGna$reactariautils.useLayoutEffect)(()=>{
-        const ownerDocument = (0, $euGna$reactariautils.getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
+        const ownerDocument = (0, $euGna$reactariautils.getRootNode)(scopeRef.current ? scopeRef.current[0] : undefined) || (0, $euGna$reactariautils.getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
         if (!restoreFocus) return;
         // Handle the Tab key so that tabbing out of the scope goes to the next element
         // after the node that had focus when the scope mounted. This is important when
@@ -470,14 +483,15 @@ function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain)
             let treeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef);
             if (!treeNode) return;
             let nodeToRestore = treeNode.nodeToRestore;
+            const rootBody = (0, $euGna$reactariautils.getRootBody)(ownerDocument);
             // Create a DOM tree walker that matches all tabbable elements
-            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(ownerDocument.body, {
+            let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(rootBody, {
                 tabbable: true
             });
             // Find the next tabbable element after the currently focused element
             walker.currentNode = focusedElement;
             let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
-            if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {
+            if (!nodeToRestore || !rootBody.contains(nodeToRestore) || nodeToRestore === rootBody) {
                 nodeToRestore = undefined;
                 treeNode.nodeToRestore = undefined;
             }
@@ -509,7 +523,8 @@ function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain)
     ]);
     // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
     (0, $euGna$reactariautils.useLayoutEffect)(()=>{
-        const ownerDocument = (0, $euGna$reactariautils.getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
+        const ownerDocument = (0, $euGna$reactariautils.getRootNode)(scopeRef.current ? scopeRef.current[0] : undefined) || (0, $euGna$reactariautils.getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
+        const rootBody = (0, $euGna$reactariautils.getRootBody)(ownerDocument);
         if (!restoreFocus) return;
         let treeNode = $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(scopeRef);
         if (!treeNode) return;
@@ -521,17 +536,17 @@ function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain)
             let nodeToRestore = treeNode.nodeToRestore;
             // if we already lost focus to the body and this was the active scope, then we should attempt to restore
             if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
-            ($a7a032acae3ddda9$var$isElementInScope(ownerDocument.activeElement, scopeRef.current) || ownerDocument.activeElement === ownerDocument.body && $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef))) {
+            ($a7a032acae3ddda9$var$isElementInScope(ownerDocument.activeElement, scopeRef.current) || ownerDocument.activeElement === rootBody && $a7a032acae3ddda9$var$shouldRestoreFocus(scopeRef))) {
                 // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                 let clonedTree = $a7a032acae3ddda9$export$d06fae2ee68b101e.clone();
                 requestAnimationFrame(()=>{
                     // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
-                    if (ownerDocument.activeElement === ownerDocument.body) {
+                    if (ownerDocument.activeElement === rootBody) {
                         // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                         let treeNode = clonedTree.getTreeNode(scopeRef);
                         while(treeNode){
                             if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {
-                                $a7a032acae3ddda9$var$focusElement(treeNode.nodeToRestore);
+                                $a7a032acae3ddda9$var$restoreFocusToElement(treeNode.nodeToRestore);
                                 return;
                             }
                             treeNode = treeNode.parent;
@@ -541,7 +556,8 @@ function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain)
                         treeNode = clonedTree.getTreeNode(scopeRef);
                         while(treeNode){
                             if (treeNode.scopeRef && treeNode.scopeRef.current && $a7a032acae3ddda9$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
-                                $a7a032acae3ddda9$var$focusFirstInScope(treeNode.scopeRef.current, true);
+                                let node = $a7a032acae3ddda9$var$getFirstInScope(treeNode.scopeRef.current, true);
+                                $a7a032acae3ddda9$var$restoreFocusToElement(node);
                                 return;
                             }
                             treeNode = treeNode.parent;
@@ -555,9 +571,20 @@ function $a7a032acae3ddda9$var$useRestoreFocus(scopeRef, restoreFocus, contain)
         restoreFocus
     ]);
 }
+function $a7a032acae3ddda9$var$restoreFocusToElement(node) {
+    // Dispatch a custom event that parent elements can intercept to customize focus restoration.
+    // For example, virtualized collection components reuse DOM elements, so the original element
+    // might still exist in the DOM but representing a different item.
+    if (node.dispatchEvent(new CustomEvent($a7a032acae3ddda9$var$RESTORE_FOCUS_EVENT, {
+        bubbles: true,
+        cancelable: true
+    }))) $a7a032acae3ddda9$var$focusElement(node);
+}
 function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
     let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $a7a032acae3ddda9$var$TABBABLE_ELEMENT_SELECTOR : $a7a032acae3ddda9$var$FOCUSABLE_ELEMENT_SELECTOR;
-    let walker = (0, $euGna$reactariautils.getOwnerDocument)(root).createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
+    let doc = root instanceof ShadowRoot ? root : (0, $euGna$reactariautils.getRootNode)(root) || (0, $euGna$reactariautils.getOwnerDocument)(root);
+    let effectiveDocument = doc instanceof ShadowRoot ? doc.ownerDocument : doc;
+    let walker = effectiveDocument.createTreeWalker(root || doc, NodeFilter.SHOW_ELEMENT, {
         acceptNode (node) {
             var _opts_from;
             // Skip nodes inside the starting node.
@@ -567,6 +594,12 @@ function $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, opts, scope) {
         }
     });
     if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
+    if (doc instanceof ShadowRoot) {
+        const originalNextNode = walker.nextNode.bind(walker);
+        const originalPreviousNode = walker.previousNode.bind(walker);
+        walker.nextNode = $a7a032acae3ddda9$var$getNextShadowNode(originalNextNode, scope);
+        walker.previousNode = $a7a032acae3ddda9$var$getPreviousShadowNode(originalPreviousNode, scope);
+    }
     return walker;
 }
 function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
@@ -575,7 +608,7 @@ function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
             let root = ref.current;
             if (!root) return null;
             let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;
-            let node = from || (0, $euGna$reactariautils.getOwnerDocument)(root).activeElement;
+            let node = from || ((0, $euGna$reactariautils.getRootNode)(root) || (0, $euGna$reactariautils.getOwnerDocument)(root)).activeElement;
             let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                 tabbable: tabbable,
                 accept: accept
@@ -593,7 +626,7 @@ function $a7a032acae3ddda9$export$c5251b9e124bf29(ref, defaultOptions = {}) {
             let root = ref.current;
             if (!root) return null;
             let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;
-            let node = from || (0, $euGna$reactariautils.getOwnerDocument)(root).activeElement;
+            let node = from || ((0, $euGna$reactariautils.getRootNode)(root) || (0, $euGna$reactariautils.getOwnerDocument)(root)).activeElement;
             let walker = $a7a032acae3ddda9$export$2d6ec8fc375ceafa(root, {
                 tabbable: tabbable,
                 accept: accept
@@ -650,6 +683,40 @@ function $a7a032acae3ddda9$var$last(walker) {
     }while (last);
     return next;
 }
+function $a7a032acae3ddda9$var$getNextShadowNode(originalNextNode, scope) {
+    return function() {
+        let nextElement = originalNextNode();
+        if (!nextElement && scope && scope.length > 0) {
+            let currentShadowRoot = scope[0].getRootNode();
+            let nextShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.nextElementSibling : null;
+            while(nextShadowHost){
+                if (nextShadowHost.shadowRoot) {
+                    let nextShadowScope = Array.from(nextShadowHost.shadowRoot.querySelectorAll('*')).filter($a7a032acae3ddda9$export$4c063cf1350e6fed);
+                    if (nextShadowScope.length > 0) return nextShadowScope[0];
+                }
+                nextShadowHost = nextShadowHost.nextElementSibling;
+            }
+        }
+        return nextElement;
+    };
+}
+function $a7a032acae3ddda9$var$getPreviousShadowNode(originalPreviousNode, scope) {
+    return function() {
+        let previousElement = originalPreviousNode();
+        if (!previousElement && scope && scope.length > 0) {
+            let currentShadowRoot = scope[0].getRootNode();
+            let previousShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.previousElementSibling : null;
+            while(previousShadowHost){
+                if (previousShadowHost.shadowRoot) {
+                    let previousShadowScope = Array.from(previousShadowHost.shadowRoot.querySelectorAll('*')).filter($a7a032acae3ddda9$export$4c063cf1350e6fed);
+                    if (previousShadowScope.length > 0) return previousShadowScope[previousShadowScope.length - 1];
+                }
+                previousShadowHost = previousShadowHost.previousElementSibling;
+            }
+        }
+        return previousElement;
+    };
+}
 class $a7a032acae3ddda9$var$Tree {
     get size() {
         return this.fastMap.size;
diff --git a/dist/FocusScope.main.js.map b/dist/FocusScope.main.js.map
index 348b47b0575f7f7049d75643fe2f9cc420f7fb0f..065067e27e7e0de10b949ee5c9d6d332573c6548 100644
--- a/dist/FocusScope.main.js.map
+++ b/dist/FocusScope.main.js.map
@@ -1 +1 @@
-{"mappings":"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","sources":["packages/@react-aria/focus/src/FocusScope.tsx"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusSafely} from './focusSafely';\nimport {getOwnerDocument, useLayoutEffect} from '@react-aria/utils';\nimport {isElementVisible} from './isElementVisible';\nimport React, {ReactNode, RefObject, useContext, useEffect, useMemo, useRef} from 'react';\n\nexport interface FocusScopeProps {\n  /** The contents of the focus scope. */\n  children: ReactNode,\n\n  /**\n   * Whether to contain focus inside the scope, so users cannot\n   * move focus outside, for example in a modal dialog.\n   */\n  contain?: boolean,\n\n  /**\n   * Whether to restore focus back to the element that was focused\n   * when the focus scope mounted, after the focus scope unmounts.\n   */\n  restoreFocus?: boolean,\n\n  /** Whether to auto focus the first focusable element in the focus scope on mount. */\n  autoFocus?: boolean\n}\n\nexport interface FocusManagerOptions {\n  /** The element to start searching from. The currently focused element by default. */\n  from?: Element,\n  /** Whether to only include tabbable elements, or all focusable elements. */\n  tabbable?: boolean,\n  /** Whether focus should wrap around when it reaches the end of the scope. */\n  wrap?: boolean,\n  /** A callback that determines whether the given element is focused. */\n  accept?: (node: Element) => boolean\n}\n\nexport interface FocusManager {\n  /** Moves focus to the next focusable or tabbable element in the focus scope. */\n  focusNext(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the previous focusable or tabbable element in the focus scope. */\n  focusPrevious(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the first focusable or tabbable element in the focus scope. */\n  focusFirst(opts?: FocusManagerOptions): FocusableElement | null,\n    /** Moves focus to the last focusable or tabbable element in the focus scope. */\n  focusLast(opts?: FocusManagerOptions): FocusableElement | null\n}\n\ntype ScopeRef = RefObject<Element[]> | null;\ninterface IFocusContext {\n  focusManager: FocusManager,\n  parentNode: TreeNode | null\n}\n\nconst FocusContext = React.createContext<IFocusContext | null>(null);\n\nlet activeScope: ScopeRef = null;\n\n// This is a hacky DOM-based implementation of a FocusScope until this RFC lands in React:\n// https://github.com/reactjs/rfcs/pull/109\n\n/**\n * A FocusScope manages focus for its descendants. It supports containing focus inside\n * the scope, restoring focus to the previously focused element on unmount, and auto\n * focusing children on mount. It also acts as a container for a programmatic focus\n * management interface that can be used to move focus forward and back in response\n * to user events.\n */\nexport function FocusScope(props: FocusScopeProps) {\n  let {children, contain, restoreFocus, autoFocus} = props;\n  let startRef = useRef<HTMLSpanElement>(null);\n  let endRef = useRef<HTMLSpanElement>(null);\n  let scopeRef = useRef<Element[]>([]);\n  let {parentNode} = useContext(FocusContext) || {};\n\n  // Create a tree node here so we can add children to it even before it is added to the tree.\n  let node = useMemo(() => new TreeNode({scopeRef}), [scopeRef]);\n\n  useLayoutEffect(() => {\n    // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),\n    // use the active scope as the parent instead of the parent from context. Layout effects run bottom\n    // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope\n    // that is being added should get the activeScope as its parent.\n    let parent = parentNode || focusScopeTree.root;\n    if (focusScopeTree.getTreeNode(parent.scopeRef) && activeScope && !isAncestorScope(activeScope, parent.scopeRef)) {\n      let activeNode = focusScopeTree.getTreeNode(activeScope);\n      if (activeNode) {\n        parent = activeNode;\n      }\n    }\n\n    // Add the node to the parent, and to the tree.\n    parent.addChild(node);\n    focusScopeTree.addNode(node);\n  }, [node, parentNode]);\n\n  useLayoutEffect(() => {\n    let node = focusScopeTree.getTreeNode(scopeRef);\n    if (node) {\n      node.contain = !!contain;\n    }\n  }, [contain]);\n\n  useLayoutEffect(() => {\n    // Find all rendered nodes between the sentinels and add them to the scope.\n    let node = startRef.current?.nextSibling!;\n    let nodes: Element[] = [];\n    while (node && node !== endRef.current) {\n      nodes.push(node as Element);\n      node = node.nextSibling as Element;\n    }\n\n    scopeRef.current = nodes;\n  }, [children]);\n\n  useActiveScopeTracker(scopeRef, restoreFocus, contain);\n  useFocusContainment(scopeRef, contain);\n  useRestoreFocus(scopeRef, restoreFocus, contain);\n  useAutoFocus(scopeRef, autoFocus);\n\n  // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.\n  // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.\n  useEffect(() => {\n    const activeElement = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement;\n    let scope: TreeNode | null = null;\n\n    if (isElementInScope(activeElement, scopeRef.current)) {\n      // We need to traverse the focusScope tree and find the bottom most scope that\n      // contains the active element and set that as the activeScope.\n      for (let node of focusScopeTree.traverse()) {\n        if (node.scopeRef && isElementInScope(activeElement, node.scopeRef.current)) {\n          scope = node;\n        }\n      }\n\n      if (scope === focusScopeTree.getTreeNode(scopeRef)) {\n        activeScope = scope.scopeRef;\n      }\n    }\n  }, [scopeRef]);\n\n  // This layout effect cleanup is so that the tree node is removed synchronously with react before the RAF\n  // in useRestoreFocus cleanup runs.\n  useLayoutEffect(() => {\n    return () => {\n      // Scope may have been re-parented.\n      let parentScope = focusScopeTree.getTreeNode(scopeRef)?.parent?.scopeRef ?? null;\n\n      if (\n        (scopeRef === activeScope || isAncestorScope(scopeRef, activeScope)) &&\n        (!parentScope || focusScopeTree.getTreeNode(parentScope))\n      ) {\n        activeScope = parentScope;\n      }\n      focusScopeTree.removeTreeNode(scopeRef);\n    };\n  }, [scopeRef]);\n\n  let focusManager = useMemo(() => createFocusManagerForScope(scopeRef), []);\n  let value = useMemo(() => ({\n    focusManager,\n    parentNode: node\n  }), [node, focusManager]);\n\n  return (\n    <FocusContext.Provider value={value}>\n      <span data-focus-scope-start hidden ref={startRef} />\n      {children}\n      <span data-focus-scope-end hidden ref={endRef} />\n    </FocusContext.Provider>\n  );\n}\n\n/**\n * Returns a FocusManager interface for the parent FocusScope.\n * A FocusManager can be used to programmatically move focus within\n * a FocusScope, e.g. in response to user events like keyboard navigation.\n */\nexport function useFocusManager(): FocusManager | undefined {\n  return useContext(FocusContext)?.focusManager;\n}\n\nfunction createFocusManagerForScope(scopeRef: React.RefObject<Element[]>): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getOwnerDocument(scope[0]).activeElement!;\n      let sentinel = scope[0].previousElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getOwnerDocument(scope[0]).activeElement!;\n      let sentinel = scope[scope.length - 1].nextElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = sentinel;\n        previousNode = walker.previousNode() as FocusableElement;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    },\n    focusFirst(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[0].previousElementSibling!;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[scope.length - 1].nextElementSibling!;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    }\n  };\n}\n\nconst focusableElements = [\n  'input:not([disabled]):not([type=hidden])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n  'button:not([disabled])',\n  'a[href]',\n  'area[href]',\n  'summary',\n  'iframe',\n  'object',\n  'embed',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]'\n];\n\nconst FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';\n\nfocusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\n\nexport function isFocusable(element: HTMLElement) {\n  return element.matches(FOCUSABLE_ELEMENT_SELECTOR);\n}\n\nfunction getScopeRoot(scope: Element[]) {\n  return scope[0].parentElement!;\n}\n\nfunction shouldContainFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.contain) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return true;\n}\n\nfunction useFocusContainment(scopeRef: RefObject<Element[]>, contain?: boolean) {\n  let focusedNode = useRef<FocusableElement>();\n\n  let raf = useRef<ReturnType<typeof requestAnimationFrame>>();\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    if (!contain) {\n      // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n        raf.current = undefined;\n      }\n      return;\n    }\n\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n\n    // Handle the Tab key to contain focus within the scope\n    let onKeyDown = (e) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef) || e.isComposing) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement;\n      let scope = scopeRef.current;\n      if (!scope || !isElementInScope(focusedElement, scope)) {\n        return;\n      }\n\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable: true}, scope);\n      if (!focusedElement) {\n        return;\n      }\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      if (!nextElement) {\n        walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling! : scope[0].previousElementSibling!;\n        nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      }\n\n      e.preventDefault();\n      if (nextElement) {\n        focusElement(nextElement, true);\n      }\n    };\n\n    let onFocus = (e) => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) && isElementInScope(e.target, scopeRef.current)) {\n        activeScope = scopeRef;\n        focusedNode.current = e.target;\n      } else if (shouldContainFocus(scopeRef) && !isElementInChildScope(e.target, scopeRef)) {\n        // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n        // restore focus to the previously focused node or the first tabbable element in the active scope.\n        if (focusedNode.current) {\n          focusedNode.current.focus();\n        } else if (activeScope && activeScope.current) {\n          focusFirstInScope(activeScope.current);\n        }\n      } else if (shouldContainFocus(scopeRef)) {\n        focusedNode.current = e.target;\n      }\n    };\n\n    let onBlur = (e) => {\n      // Firefox doesn't shift focus back to the Dialog properly without this\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n      raf.current = requestAnimationFrame(() => {\n        // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n        if (ownerDocument.activeElement && shouldContainFocus(scopeRef) && !isElementInChildScope(ownerDocument.activeElement, scopeRef)) {\n          activeScope = scopeRef;\n          if (ownerDocument.body.contains(e.target)) {\n            focusedNode.current = e.target;\n            focusedNode.current?.focus();\n          } else if (activeScope.current) {\n            focusFirstInScope(activeScope.current);\n          }\n        }\n      });\n    };\n\n    ownerDocument.addEventListener('keydown', onKeyDown, false);\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    scope?.forEach(element => element.addEventListener('focusout', onBlur, false));\n    return () => {\n      ownerDocument.removeEventListener('keydown', onKeyDown, false);\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n      scope?.forEach(element => element.removeEventListener('focusout', onBlur, false));\n    };\n  }, [scopeRef, contain]);\n\n  // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur\n  // eslint-disable-next-line arrow-body-style\n  useLayoutEffect(() => {\n    return () => {\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n    };\n  }, [raf]);\n}\n\nfunction isElementInAnyScope(element: Element) {\n  return isElementInChildScope(element);\n}\n\nfunction isElementInScope(element?: Element | null, scope?: Element[] | null) {\n  if (!element) {\n    return false;\n  }\n  if (!scope) {\n    return false;\n  }\n  return scope.some(node => node.contains(element));\n}\n\nfunction isElementInChildScope(element: Element, scope: ScopeRef = null) {\n  // If the element is within a top layer element (e.g. toasts), always allow moving focus there.\n  if (element instanceof Element && element.closest('[data-react-aria-top-layer]')) {\n    return true;\n  }\n\n  // node.contains in isElementInScope covers child scopes that are also DOM children,\n  // but does not cover child scopes in portals.\n  for (let {scopeRef: s} of focusScopeTree.traverse(focusScopeTree.getTreeNode(scope))) {\n    if (s && isElementInScope(element, s.current)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/** @private */\nexport function isElementInChildOfActiveScope(element: Element) {\n  return isElementInChildScope(element, activeScope);\n}\n\nfunction isAncestorScope(ancestor: ScopeRef, scope: ScopeRef) {\n  let parent = focusScopeTree.getTreeNode(scope)?.parent;\n  while (parent) {\n    if (parent.scopeRef === ancestor) {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction focusElement(element: FocusableElement | null, scroll = false) {\n  if (element != null && !scroll) {\n    try {\n      focusSafely(element);\n    } catch (err) {\n      // ignore\n    }\n  } else if (element != null) {\n    try {\n      element.focus();\n    } catch (err) {\n      // ignore\n    }\n  }\n}\n\nfunction focusFirstInScope(scope: Element[], tabbable:boolean = true) {\n  let sentinel = scope[0].previousElementSibling!;\n  let scopeRoot = getScopeRoot(scope);\n  let walker = getFocusableTreeWalker(scopeRoot, {tabbable}, scope);\n  walker.currentNode = sentinel;\n  let nextNode = walker.nextNode();\n\n  // If the scope does not contain a tabbable element, use the first focusable element.\n  if (tabbable && !nextNode) {\n    scopeRoot = getScopeRoot(scope);\n    walker = getFocusableTreeWalker(scopeRoot, {tabbable: false}, scope);\n    walker.currentNode = sentinel;\n    nextNode = walker.nextNode();\n  }\n\n  focusElement(nextNode as FocusableElement);\n}\n\nfunction useAutoFocus(scopeRef: RefObject<Element[]>, autoFocus?: boolean) {\n  const autoFocusRef = React.useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      activeScope = scopeRef;\n      const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n      if (!isElementInScope(ownerDocument.activeElement, activeScope.current) && scopeRef.current) {\n        focusFirstInScope(scopeRef.current);\n      }\n    }\n    autoFocusRef.current = false;\n  }, [scopeRef]);\n}\n\nfunction useActiveScopeTracker(scopeRef: RefObject<Element[]>, restore?: boolean, contain?: boolean) {\n  // tracks the active scope, in case restore and contain are both false.\n  // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n  useLayoutEffect(() => {\n    if (restore || contain) {\n      return;\n    }\n\n    let scope = scopeRef.current;\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n\n    let onFocus = (e) => {\n      let target = e.target as Element;\n      if (isElementInScope(target, scopeRef.current)) {\n        activeScope = scopeRef;\n      } else if (!isElementInAnyScope(target)) {\n        activeScope = null;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n  }, [scopeRef, restore, contain]);\n}\n\nfunction shouldRestoreFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.nodeToRestore) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return scope?.scopeRef === scopeRef;\n}\n\nfunction useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean, contain?: boolean) {\n  // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n  // eslint-disable-next-line no-restricted-globals\n  const nodeToRestoreRef = useRef(typeof document !== 'undefined' ? getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement as FocusableElement : null);\n\n  // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n  // restoring-non-containing scopes should only care if they become active so they can perform the restore\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n    if (!restoreFocus || contain) {\n      return;\n    }\n\n    let onFocus = () => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) &&\n      isElementInScope(ownerDocument.activeElement, scopeRef.current)\n      ) {\n        activeScope = scopeRef;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [scopeRef, contain]);\n\n  useLayoutEffect(() => {\n    const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    // Handle the Tab key so that tabbing out of the scope goes to the next element\n    // after the node that had focus when the scope mounted. This is important when\n    // using portals for overlays, so that focus goes to the expected element when\n    // tabbing out of the overlay.\n    let onKeyDown = (e: KeyboardEvent) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef) || e.isComposing) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement as FocusableElement;\n      if (!isElementInScope(focusedElement, scopeRef.current)) {\n        return;\n      }\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      // Create a DOM tree walker that matches all tabbable elements\n      let walker = getFocusableTreeWalker(ownerDocument.body, {tabbable: true});\n\n      // Find the next tabbable element after the currently focused element\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n\n      if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {\n        nodeToRestore = undefined;\n        treeNode.nodeToRestore = undefined;\n      }\n\n      // If there is no next element, or it is outside the current scope, move focus to the\n      // next element after the node to restore to instead.\n      if ((!nextElement || !isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n        walker.currentNode = nodeToRestore;\n\n        // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n        do {\n          nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n        } while (isElementInScope(nextElement, scopeRef.current));\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (nextElement) {\n          focusElement(nextElement, true);\n        } else {\n           // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)\n           // then move focus to the body.\n           // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n          if (!isElementInAnyScope(nodeToRestore)) {\n            focusedElement.blur();\n          } else {\n            focusElement(nodeToRestore, true);\n          }\n        }\n      }\n    };\n\n    if (!contain) {\n      ownerDocument.addEventListener('keydown', onKeyDown, true);\n    }\n\n    return () => {\n      if (!contain) {\n        ownerDocument.removeEventListener('keydown', onKeyDown, true);\n      }\n    };\n  }, [scopeRef, restoreFocus, contain]);\n\n  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n  useLayoutEffect(() => {\n    const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    let treeNode = focusScopeTree.getTreeNode(scopeRef);\n    if (!treeNode) {\n      return;\n    }\n    treeNode.nodeToRestore = nodeToRestoreRef.current ?? undefined;\n    return () => {\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n      if (\n        restoreFocus\n        && nodeToRestore\n        && (\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          isElementInScope(ownerDocument.activeElement, scopeRef.current)\n          || (ownerDocument.activeElement === ownerDocument.body && shouldRestoreFocus(scopeRef))\n        )\n      ) {\n        // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n        let clonedTree = focusScopeTree.clone();\n        requestAnimationFrame(() => {\n          // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n          if (ownerDocument.activeElement === ownerDocument.body) {\n            // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n            let treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {\n                focusElement(treeNode.nodeToRestore);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n\n            // If no nodeToRestore was found, focus the first element in the nearest\n            // ancestor scope that is still in the tree.\n            treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.scopeRef && treeNode.scopeRef.current && focusScopeTree.getTreeNode(treeNode.scopeRef)) {\n                focusFirstInScope(treeNode.scopeRef.current, true);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n          }\n        });\n      }\n    };\n  }, [scopeRef, restoreFocus]);\n}\n\n/**\n * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}\n * that matches all focusable/tabbable elements.\n */\nexport function getFocusableTreeWalker(root: Element, opts?: FocusManagerOptions, scope?: Element[]) {\n  let selector = opts?.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;\n  let walker = getOwnerDocument(root).createTreeWalker(\n    root,\n    NodeFilter.SHOW_ELEMENT,\n    {\n      acceptNode(node) {\n        // Skip nodes inside the starting node.\n        if (opts?.from?.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if ((node as Element).matches(selector)\n          && isElementVisible(node as Element)\n          && (!scope || isElementInScope(node as Element, scope))\n          && (!opts?.accept || opts.accept(node as Element))\n        ) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      }\n    }\n  );\n\n  if (opts?.from) {\n    walker.currentNode = opts.from;\n  }\n\n  return walker;\n}\n\n/**\n * Creates a FocusManager object that can be used to move focus within an element.\n */\nexport function createFocusManager(ref: RefObject<Element>, defaultOptions: FocusManagerOptions = {}): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || getOwnerDocument(root).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      }\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = root;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || getOwnerDocument(root).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      } else {\n        let next = last(walker);\n        if (next) {\n          focusElement(next, true);\n        }\n        return next ?? null;\n      }\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = root;\n        let lastNode = last(walker);\n        if (!lastNode) {\n          // couldn't wrap\n          return null;\n        }\n        previousNode = lastNode;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode ?? null;\n    },\n    focusFirst(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let next = last(walker);\n      if (next) {\n        focusElement(next, true);\n      }\n      return next ?? null;\n    }\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement | undefined = undefined;\n  let last: FocusableElement;\n  do {\n    last = walker.lastChild() as FocusableElement;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n\n\nclass Tree {\n  root: TreeNode;\n  private fastMap = new Map<ScopeRef, TreeNode>();\n\n  constructor() {\n    this.root = new TreeNode({scopeRef: null});\n    this.fastMap.set(null, this.root);\n  }\n\n  get size() {\n    return this.fastMap.size;\n  }\n\n  getTreeNode(data: ScopeRef) {\n    return this.fastMap.get(data);\n  }\n\n  addTreeNode(scopeRef: ScopeRef, parent: ScopeRef, nodeToRestore?: FocusableElement) {\n    let parentNode = this.fastMap.get(parent ?? null);\n    if (!parentNode) {\n      return;\n    }\n    let node = new TreeNode({scopeRef});\n    parentNode.addChild(node);\n    node.parent = parentNode;\n    this.fastMap.set(scopeRef, node);\n    if (nodeToRestore) {\n      node.nodeToRestore = nodeToRestore;\n    }\n  }\n\n  addNode(node: TreeNode) {\n    this.fastMap.set(node.scopeRef, node);\n  }\n\n  removeTreeNode(scopeRef: ScopeRef) {\n    // never remove the root\n    if (scopeRef === null) {\n      return;\n    }\n    let node = this.fastMap.get(scopeRef);\n    if (!node) {\n      return;\n    }\n    let parentNode = node.parent;\n    // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n    // if we are, then replace the siblings restore with the restore from the scope we're removing\n    for (let current of this.traverse()) {\n      if (\n        current !== node &&\n        node.nodeToRestore &&\n        current.nodeToRestore &&\n        node.scopeRef &&\n        node.scopeRef.current &&\n        isElementInScope(current.nodeToRestore, node.scopeRef.current)\n      ) {\n        current.nodeToRestore = node.nodeToRestore;\n      }\n    }\n    let children = node.children;\n    if (parentNode) {\n      parentNode.removeChild(node);\n      if (children.size > 0) {\n        children.forEach(child => parentNode && parentNode.addChild(child));\n      }\n    }\n\n    this.fastMap.delete(node.scopeRef);\n  }\n\n  // Pre Order Depth First\n  *traverse(node: TreeNode = this.root): Generator<TreeNode> {\n    if (node.scopeRef != null) {\n      yield node;\n    }\n    if (node.children.size > 0) {\n      for (let child of node.children) {\n        yield* this.traverse(child);\n      }\n    }\n  }\n\n  clone(): Tree {\n    let newTree = new Tree();\n    for (let node of this.traverse()) {\n      newTree.addTreeNode(node.scopeRef, node.parent?.scopeRef ?? null, node.nodeToRestore);\n    }\n    return newTree;\n  }\n}\n\nclass TreeNode {\n  public scopeRef: ScopeRef;\n  public nodeToRestore?: FocusableElement;\n  public parent?: TreeNode;\n  public children: Set<TreeNode> = new Set();\n  public contain = false;\n\n  constructor(props: {scopeRef: ScopeRef}) {\n    this.scopeRef = props.scopeRef;\n  }\n  addChild(node: TreeNode) {\n    this.children.add(node);\n    node.parent = this;\n  }\n  removeChild(node: TreeNode) {\n    this.children.delete(node);\n    node.parent = undefined;\n  }\n}\n\nexport let focusScopeTree = new Tree();\n"],"names":[],"version":3,"file":"FocusScope.main.js.map"}
\ No newline at end of file
+{"mappings":"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","sources":["packages/@react-aria/focus/src/FocusScope.tsx"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusSafely} from './focusSafely';\nimport {getOwnerDocument, getRootBody, getRootNode, useLayoutEffect} from '@react-aria/utils';\nimport {isElementVisible} from './isElementVisible';\nimport React, {ReactNode, RefObject, useContext, useEffect, useMemo, useRef} from 'react';\n\nexport interface FocusScopeProps {\n  /** The contents of the focus scope. */\n  children: ReactNode,\n\n  /**\n   * Whether to contain focus inside the scope, so users cannot\n   * move focus outside, for example in a modal dialog.\n   */\n  contain?: boolean,\n\n  /**\n   * Whether to restore focus back to the element that was focused\n   * when the focus scope mounted, after the focus scope unmounts.\n   */\n  restoreFocus?: boolean,\n\n  /** Whether to auto focus the first focusable element in the focus scope on mount. */\n  autoFocus?: boolean\n}\n\nexport interface FocusManagerOptions {\n  /** The element to start searching from. The currently focused element by default. */\n  from?: Element,\n  /** Whether to only include tabbable elements, or all focusable elements. */\n  tabbable?: boolean,\n  /** Whether focus should wrap around when it reaches the end of the scope. */\n  wrap?: boolean,\n  /** A callback that determines whether the given element is focused. */\n  accept?: (node: Element) => boolean\n}\n\nexport interface FocusManager {\n  /** Moves focus to the next focusable or tabbable element in the focus scope. */\n  focusNext(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the previous focusable or tabbable element in the focus scope. */\n  focusPrevious(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the first focusable or tabbable element in the focus scope. */\n  focusFirst(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the last focusable or tabbable element in the focus scope. */\n  focusLast(opts?: FocusManagerOptions): FocusableElement | null\n}\n\ntype ScopeRef = RefObject<Element[] | null> | null;\ninterface IFocusContext {\n  focusManager: FocusManager,\n  parentNode: TreeNode | null\n}\n\nconst FocusContext = React.createContext<IFocusContext | null>(null);\nconst RESTORE_FOCUS_EVENT = 'react-aria-focus-scope-restore';\n\nlet activeScope: ScopeRef = null;\n\n// This is a hacky DOM-based implementation of a FocusScope until this RFC lands in React:\n// https://github.com/reactjs/rfcs/pull/109\n\n/**\n * A FocusScope manages focus for its descendants. It supports containing focus inside\n * the scope, restoring focus to the previously focused element on unmount, and auto\n * focusing children on mount. It also acts as a container for a programmatic focus\n * management interface that can be used to move focus forward and back in response\n * to user events.\n */\nexport function FocusScope(props: FocusScopeProps) {\n  let {children, contain, restoreFocus, autoFocus} = props;\n  let startRef = useRef<HTMLSpanElement>(null);\n  let endRef = useRef<HTMLSpanElement>(null);\n  let scopeRef = useRef<Element[]>([]);\n  let {parentNode} = useContext(FocusContext) || {};\n\n  // Create a tree node here so we can add children to it even before it is added to the tree.\n  let node = useMemo(() => new TreeNode({scopeRef}), [scopeRef]);\n\n  useLayoutEffect(() => {\n    // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),\n    // use the active scope as the parent instead of the parent from context. Layout effects run bottom\n    // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope\n    // that is being added should get the activeScope as its parent.\n    let parent = parentNode || focusScopeTree.root;\n    if (focusScopeTree.getTreeNode(parent.scopeRef) && activeScope && !isAncestorScope(activeScope, parent.scopeRef)) {\n      let activeNode = focusScopeTree.getTreeNode(activeScope);\n      if (activeNode) {\n        parent = activeNode;\n      }\n    }\n\n    // Add the node to the parent, and to the tree.\n    parent.addChild(node);\n    focusScopeTree.addNode(node);\n  }, [node, parentNode]);\n\n  useLayoutEffect(() => {\n    let node = focusScopeTree.getTreeNode(scopeRef);\n    if (node) {\n      node.contain = !!contain;\n    }\n  }, [contain]);\n\n  useLayoutEffect(() => {\n    // Find all rendered nodes between the sentinels and add them to the scope.\n    let node = startRef.current?.nextSibling!;\n    let nodes: Element[] = [];\n    let stopPropagation = e => e.stopPropagation();\n    while (node && node !== endRef.current) {\n      nodes.push(node as Element);\n      // Stop custom restore focus event from propagating to parent focus scopes.\n      node.addEventListener(RESTORE_FOCUS_EVENT, stopPropagation);\n      node = node.nextSibling as Element;\n    }\n\n    scopeRef.current = nodes;\n\n    return () => {\n      for (let node of nodes) {\n        node.removeEventListener(RESTORE_FOCUS_EVENT, stopPropagation);\n      }\n    };\n  }, [children]);\n\n  useActiveScopeTracker(scopeRef, restoreFocus, contain);\n  useFocusContainment(scopeRef, contain);\n  useRestoreFocus(scopeRef, restoreFocus, contain);\n  useAutoFocus(scopeRef, autoFocus);\n\n  // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.\n  // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.\n  useEffect(() => {\n    const activeElement = getRootNode(scopeRef.current ? scopeRef.current[0] : undefined)?.activeElement;\n    let scope: TreeNode | null = null;\n\n    if (isElementInScope(activeElement, scopeRef.current)) {\n      // We need to traverse the focusScope tree and find the bottom most scope that\n      // contains the active element and set that as the activeScope.\n      for (let node of focusScopeTree.traverse()) {\n        if (node.scopeRef && isElementInScope(activeElement, node.scopeRef.current)) {\n          scope = node;\n        }\n      }\n\n      if (scope === focusScopeTree.getTreeNode(scopeRef)) {\n        activeScope = scope.scopeRef;\n      }\n    }\n  }, [scopeRef]);\n\n  // This layout effect cleanup is so that the tree node is removed synchronously with react before the RAF\n  // in useRestoreFocus cleanup runs.\n  useLayoutEffect(() => {\n    return () => {\n      // Scope may have been re-parented.\n      let parentScope = focusScopeTree.getTreeNode(scopeRef)?.parent?.scopeRef ?? null;\n\n      if (\n        (scopeRef === activeScope || isAncestorScope(scopeRef, activeScope)) &&\n        (!parentScope || focusScopeTree.getTreeNode(parentScope))\n      ) {\n        activeScope = parentScope;\n      }\n      focusScopeTree.removeTreeNode(scopeRef);\n    };\n  }, [scopeRef]);\n\n  let focusManager = useMemo(() => createFocusManagerForScope(scopeRef), []);\n  let value = useMemo(() => ({\n    focusManager,\n    parentNode: node\n  }), [node, focusManager]);\n\n  return (\n    <FocusContext.Provider value={value}>\n      <span data-focus-scope-start hidden ref={startRef} />\n      {children}\n      <span data-focus-scope-end hidden ref={endRef} />\n    </FocusContext.Provider>\n  );\n}\n\n/**\n * Returns a FocusManager interface for the parent FocusScope.\n * A FocusManager can be used to programmatically move focus within\n * a FocusScope, e.g. in response to user events like keyboard navigation.\n */\nexport function useFocusManager(): FocusManager | undefined {\n  return useContext(FocusContext)?.focusManager;\n}\n\nfunction createFocusManagerForScope(scopeRef: React.RefObject<Element[] | null>): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getRootNode(scope[0])?.activeElement!;\n      let sentinel = scope[0].previousElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getRootNode(scope[0])?.activeElement!;\n      let sentinel = scope[scope.length - 1].nextElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = sentinel;\n        previousNode = walker.previousNode() as FocusableElement;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    },\n    focusFirst(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[0].previousElementSibling!;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[scope.length - 1].nextElementSibling!;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    }\n  };\n}\n\nconst focusableElements = [\n  'input:not([disabled]):not([type=hidden])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n  'button:not([disabled])',\n  'a[href]',\n  'area[href]',\n  'summary',\n  'iframe',\n  'object',\n  'embed',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]'\n];\n\nconst FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';\n\nfocusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\n\nexport function isFocusable(element: Element) {\n  return element.matches(FOCUSABLE_ELEMENT_SELECTOR);\n}\n\nfunction getScopeRoot(scope: Element[]) {\n  return scope[0].parentElement!;\n}\n\nfunction shouldContainFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.contain) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return true;\n}\n\nfunction useFocusContainment(scopeRef: RefObject<Element[] | null>, contain?: boolean) {\n  let focusedNode = useRef<FocusableElement>(undefined);\n\n  let raf = useRef<ReturnType<typeof requestAnimationFrame>>(undefined);\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    if (!contain) {\n      // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n        raf.current = undefined;\n      }\n      return;\n    }\n\n    const ownerDocument = getRootNode(scope ? scope[0] : undefined) || getOwnerDocument(scope ? scope[0] : undefined);\n\n    // Handle the Tab key to contain focus within the scope\n    let onKeyDown = (e) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef) || e.isComposing) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement;\n      let scope = scopeRef.current;\n      if (!scope || !isElementInScope(focusedElement, scope)) {\n        return;\n      }\n\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable: true}, scope);\n      if (!focusedElement) {\n        return;\n      }\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      if (!nextElement) {\n        walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling! : scope[0].previousElementSibling!;\n        nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      }\n\n      e.preventDefault();\n      if (nextElement) {\n        focusElement(nextElement, true);\n      }\n    };\n\n    let onFocus = (e) => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) && isElementInScope(e.target, scopeRef.current)) {\n        activeScope = scopeRef;\n        focusedNode.current = e.target;\n      } else if (shouldContainFocus(scopeRef) && !isElementInChildScope(e.target, scopeRef)) {\n        // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n        // restore focus to the previously focused node or the first tabbable element in the active scope.\n        if (focusedNode.current) {\n          focusedNode.current.focus();\n        } else if (activeScope && activeScope.current) {\n          focusFirstInScope(activeScope.current);\n        }\n      } else if (shouldContainFocus(scopeRef)) {\n        focusedNode.current = e.target;\n      }\n    };\n\n    let onBlur = (e) => {\n      // Firefox doesn't shift focus back to the Dialog properly without this\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n      raf.current = requestAnimationFrame(() => {\n        // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n        if (ownerDocument.activeElement && shouldContainFocus(scopeRef) && !isElementInChildScope(ownerDocument.activeElement, scopeRef)) {\n          activeScope = scopeRef;\n          if (getRootBody(ownerDocument).contains(e.target)) {\n            focusedNode.current = e.target;\n            focusedNode.current?.focus();\n          } else if (activeScope.current) {\n            focusFirstInScope(activeScope.current);\n          }\n        }\n      });\n    };\n\n    ownerDocument.addEventListener('keydown', onKeyDown, false);\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    scope?.forEach(element => element.addEventListener('focusout', onBlur, false));\n    return () => {\n      ownerDocument.removeEventListener('keydown', onKeyDown, false);\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n      scope?.forEach(element => element.removeEventListener('focusout', onBlur, false));\n    };\n  }, [scopeRef, contain]);\n\n  // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur\n  // eslint-disable-next-line arrow-body-style\n  useLayoutEffect(() => {\n    return () => {\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n    };\n  }, [raf]);\n}\n\nfunction isElementInAnyScope(element: Element) {\n  return isElementInChildScope(element);\n}\n\nfunction isElementInScope(element?: Element | null, scope?: Element[] | null) {\n  if (!element) {\n    return false;\n  }\n  if (!scope) {\n    return false;\n  }\n  return scope.some(node => node.contains(element));\n}\n\nfunction isElementInChildScope(element: Element, scope: ScopeRef = null) {\n  // If the element is within a top layer element (e.g. toasts), always allow moving focus there.\n  if (element instanceof Element && element.closest('[data-react-aria-top-layer]')) {\n    return true;\n  }\n\n  // node.contains in isElementInScope covers child scopes that are also DOM children,\n  // but does not cover child scopes in portals.\n  for (let {scopeRef: s} of focusScopeTree.traverse(focusScopeTree.getTreeNode(scope))) {\n    if (s && isElementInScope(element, s.current)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/** @private */\nexport function isElementInChildOfActiveScope(element: Element) {\n  return isElementInChildScope(element, activeScope);\n}\n\nfunction isAncestorScope(ancestor: ScopeRef, scope: ScopeRef) {\n  let parent = focusScopeTree.getTreeNode(scope)?.parent;\n  while (parent) {\n    if (parent.scopeRef === ancestor) {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction focusElement(element: FocusableElement | null, scroll = false) {\n  if (element != null && !scroll) {\n    try {\n      focusSafely(element);\n    } catch (err) {\n      // ignore\n    }\n  } else if (element != null) {\n    try {\n      element.focus();\n    } catch (err) {\n      // ignore\n    }\n  }\n}\n\nfunction getFirstInScope(scope: Element[], tabbable = true) {\n  let sentinel = scope[0].previousElementSibling!;\n  let scopeRoot = getScopeRoot(scope);\n  let walker = getFocusableTreeWalker(scopeRoot, {tabbable}, scope);\n  walker.currentNode = sentinel;\n  let nextNode = walker.nextNode();\n\n  // If the scope does not contain a tabbable element, use the first focusable element.\n  if (tabbable && !nextNode) {\n    scopeRoot = getScopeRoot(scope);\n    walker = getFocusableTreeWalker(scopeRoot, {tabbable: false}, scope);\n    walker.currentNode = sentinel;\n    nextNode = walker.nextNode();\n  }\n\n  return nextNode as FocusableElement;\n}\n\nfunction focusFirstInScope(scope: Element[], tabbable:boolean = true) {\n  focusElement(getFirstInScope(scope, tabbable));\n}\n\nfunction useAutoFocus(scopeRef: RefObject<Element[] | null>, autoFocus?: boolean) {\n  const autoFocusRef = React.useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      activeScope = scopeRef;\n      const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n      if (!isElementInScope(ownerDocument.activeElement, activeScope.current) && scopeRef.current) {\n        focusFirstInScope(scopeRef.current);\n      }\n    }\n    autoFocusRef.current = false;\n  }, [scopeRef]);\n}\n\nfunction useActiveScopeTracker(scopeRef: RefObject<Element[] | null>, restore?: boolean, contain?: boolean) {\n  // tracks the active scope, in case restore and contain are both false.\n  // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n  useLayoutEffect(() => {\n    if (restore || contain) {\n      return;\n    }\n\n    let scope = scopeRef.current;\n    const ownerDocument = getRootNode(scope ? scope[0] : undefined) || getOwnerDocument(scope ? scope[0] : undefined);\n\n    let onFocus = (e) => {\n      let target = e.target as Element;\n      if (isElementInScope(target, scopeRef.current)) {\n        activeScope = scopeRef;\n      } else if (!isElementInAnyScope(target)) {\n        activeScope = null;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n  }, [scopeRef, restore, contain]);\n}\n\nfunction shouldRestoreFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.nodeToRestore) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return scope?.scopeRef === scopeRef;\n}\n\nfunction useRestoreFocus(scopeRef: RefObject<Element[] | null>, restoreFocus?: boolean, contain?: boolean) {\n  // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n  // eslint-disable-next-line no-restricted-globals\n  const nodeToRestoreRef = useRef(typeof document !== 'undefined' ? getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement as FocusableElement : null);\n\n  // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n  // restoring-non-containing scopes should only care if they become active so they can perform the restore\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    const ownerDocument = getRootNode(scope ? scope[0] : undefined) || getOwnerDocument(scope ? scope[0] : undefined);\n    if (!restoreFocus || contain) {\n      return;\n    }\n\n    let onFocus = () => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) &&\n        isElementInScope(ownerDocument.activeElement, scopeRef.current)\n      ) {\n        activeScope = scopeRef;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [scopeRef, contain]);\n\n  useLayoutEffect(() => {\n    const ownerDocument = getRootNode(scopeRef.current ? scopeRef.current[0] : undefined) || getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    // Handle the Tab key so that tabbing out of the scope goes to the next element\n    // after the node that had focus when the scope mounted. This is important when\n    // using portals for overlays, so that focus goes to the expected element when\n    // tabbing out of the overlay.\n    let onKeyDown = (e: KeyboardEvent) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef) || e.isComposing) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement as FocusableElement;\n      if (!isElementInScope(focusedElement, scopeRef.current)) {\n        return;\n      }\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      const rootBody = getRootBody(ownerDocument);\n\n      // Create a DOM tree walker that matches all tabbable elements\n      let walker = getFocusableTreeWalker(rootBody, {tabbable: true});\n\n      // Find the next tabbable element after the currently focused element\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n\n      if (!nodeToRestore || !rootBody.contains(nodeToRestore) || nodeToRestore === rootBody) {\n        nodeToRestore = undefined;\n        treeNode.nodeToRestore = undefined;\n      }\n\n      // If there is no next element, or it is outside the current scope, move focus to the\n      // next element after the node to restore to instead.\n      if ((!nextElement || !isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n        walker.currentNode = nodeToRestore;\n\n        // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n        do {\n          nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n        } while (isElementInScope(nextElement, scopeRef.current));\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (nextElement) {\n          focusElement(nextElement, true);\n        } else {\n          // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)\n          // then move focus to the body.\n          // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n          if (!isElementInAnyScope(nodeToRestore)) {\n            focusedElement.blur();\n          } else {\n            focusElement(nodeToRestore, true);\n          }\n        }\n      }\n    };\n\n    if (!contain) {\n      ownerDocument.addEventListener('keydown', onKeyDown as EventListener, true);\n    }\n\n    return () => {\n      if (!contain) {\n        ownerDocument.removeEventListener('keydown', onKeyDown as EventListener, true);\n      }\n    };\n  }, [scopeRef, restoreFocus, contain]);\n\n  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n  useLayoutEffect(() => {\n    const ownerDocument = getRootNode(scopeRef.current ? scopeRef.current[0] : undefined) || getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n    const rootBody = getRootBody(ownerDocument);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    let treeNode = focusScopeTree.getTreeNode(scopeRef);\n    if (!treeNode) {\n      return;\n    }\n    treeNode.nodeToRestore = nodeToRestoreRef.current ?? undefined;\n    return () => {\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n      if (\n        restoreFocus\n        && nodeToRestore\n        && (\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          (isElementInScope(ownerDocument.activeElement, scopeRef.current) || (ownerDocument.activeElement === rootBody && shouldRestoreFocus(scopeRef)))\n        )\n      ) {\n        // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n        let clonedTree = focusScopeTree.clone();\n        requestAnimationFrame(() => {\n          // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n          if (ownerDocument.activeElement === rootBody) {\n            // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n            let treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {\n                restoreFocusToElement(treeNode.nodeToRestore);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n\n            // If no nodeToRestore was found, focus the first element in the nearest\n            // ancestor scope that is still in the tree.\n            treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.scopeRef && treeNode.scopeRef.current && focusScopeTree.getTreeNode(treeNode.scopeRef)) {\n                let node = getFirstInScope(treeNode.scopeRef.current, true);\n                restoreFocusToElement(node);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n          }\n        });\n      }\n    };\n  }, [scopeRef, restoreFocus]);\n}\n\nfunction restoreFocusToElement(node: FocusableElement) {\n  // Dispatch a custom event that parent elements can intercept to customize focus restoration.\n  // For example, virtualized collection components reuse DOM elements, so the original element\n  // might still exist in the DOM but representing a different item.\n  if (node.dispatchEvent(new CustomEvent(RESTORE_FOCUS_EVENT, {bubbles: true, cancelable: true}))) {\n    focusElement(node);\n  }\n}\n\n/**\n * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}\n * that matches all focusable/tabbable elements.\n */\nexport function getFocusableTreeWalker(root: Element | ShadowRoot, opts?: FocusManagerOptions, scope?: Element[]) {\n  let selector = opts?.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;\n  let doc = root instanceof ShadowRoot ? root :  (getRootNode(root) || getOwnerDocument(root));\n  let effectiveDocument = doc instanceof ShadowRoot ? doc.ownerDocument : doc;\n  let walker = effectiveDocument.createTreeWalker(\n    root || doc,\n    NodeFilter.SHOW_ELEMENT,\n    {\n      acceptNode(node) {\n        // Skip nodes inside the starting node.\n        if (opts?.from?.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if ((node as Element).matches(selector)\n          && isElementVisible(node as Element)\n          && (!scope || isElementInScope(node as Element, scope))\n          && (!opts?.accept || opts.accept(node as Element))\n        ) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      }\n    }\n  );\n\n  if (opts?.from) {\n    walker.currentNode = opts.from;\n  }\n\n  if (doc instanceof ShadowRoot) {\n    const originalNextNode = walker.nextNode.bind(walker);\n    const originalPreviousNode = walker.previousNode.bind(walker);\n    walker.nextNode = getNextShadowNode(originalNextNode, scope);\n    walker.previousNode = getPreviousShadowNode(originalPreviousNode, scope);\n  }\n\n  return walker;\n}\n\n/**\n * Creates a FocusManager object that can be used to move focus within an element.\n */\nexport function createFocusManager(ref: RefObject<Element | null>, defaultOptions: FocusManagerOptions = {}): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || (getRootNode(root) || getOwnerDocument(root)).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      }\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = root;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || (getRootNode(root) || getOwnerDocument(root)).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      } else {\n        let next = last(walker);\n        if (next) {\n          focusElement(next, true);\n        }\n        return next ?? null;\n      }\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = root;\n        let lastNode = last(walker);\n        if (!lastNode) {\n          // couldn't wrap\n          return null;\n        }\n        previousNode = lastNode;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode ?? null;\n    },\n    focusFirst(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let next = last(walker);\n      if (next) {\n        focusElement(next, true);\n      }\n      return next ?? null;\n    }\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement | undefined = undefined;\n  let last: FocusableElement;\n  do {\n    last = walker.lastChild() as FocusableElement;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n\nfunction getNextShadowNode(originalNextNode: () => Node | null, scope?: Element[]) {\n  return function () {\n    let nextElement = originalNextNode();\n    if (!nextElement && scope && scope.length > 0) {\n      let currentShadowRoot = scope[0].getRootNode();\n      let nextShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.nextElementSibling : null;\n      while (nextShadowHost) {\n        if (nextShadowHost.shadowRoot) {\n          let nextShadowScope = Array.from(nextShadowHost.shadowRoot.querySelectorAll('*')).filter(isFocusable);\n          if (nextShadowScope.length > 0) {\n            return nextShadowScope[0];\n          }\n        }\n        nextShadowHost = nextShadowHost.nextElementSibling;\n      }\n    }\n    return nextElement;\n  };\n}\n\nfunction getPreviousShadowNode(originalPreviousNode: () => Node | null, scope?: Element[]) {\n  return function () {\n    let previousElement = originalPreviousNode();\n    if (!previousElement && scope && scope.length > 0) {\n      let currentShadowRoot = scope[0].getRootNode();\n      let previousShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.previousElementSibling : null;\n      while (previousShadowHost) {\n        if (previousShadowHost.shadowRoot) {\n          let previousShadowScope = Array.from(previousShadowHost.shadowRoot.querySelectorAll('*')).filter(isFocusable);\n          if (previousShadowScope.length > 0) {\n            return previousShadowScope[previousShadowScope.length - 1];\n          }\n        }\n        previousShadowHost = previousShadowHost.previousElementSibling;\n      }\n    }\n    return previousElement;\n  };\n}\n\n\nclass Tree {\n  root: TreeNode;\n  private fastMap = new Map<ScopeRef, TreeNode>();\n\n  constructor() {\n    this.root = new TreeNode({scopeRef: null});\n    this.fastMap.set(null, this.root);\n  }\n\n  get size() {\n    return this.fastMap.size;\n  }\n\n  getTreeNode(data: ScopeRef) {\n    return this.fastMap.get(data);\n  }\n\n  addTreeNode(scopeRef: ScopeRef, parent: ScopeRef, nodeToRestore?: FocusableElement) {\n    let parentNode = this.fastMap.get(parent ?? null);\n    if (!parentNode) {\n      return;\n    }\n    let node = new TreeNode({scopeRef});\n    parentNode.addChild(node);\n    node.parent = parentNode;\n    this.fastMap.set(scopeRef, node);\n    if (nodeToRestore) {\n      node.nodeToRestore = nodeToRestore;\n    }\n  }\n\n  addNode(node: TreeNode) {\n    this.fastMap.set(node.scopeRef, node);\n  }\n\n  removeTreeNode(scopeRef: ScopeRef) {\n    // never remove the root\n    if (scopeRef === null) {\n      return;\n    }\n    let node = this.fastMap.get(scopeRef);\n    if (!node) {\n      return;\n    }\n    let parentNode = node.parent;\n    // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n    // if we are, then replace the siblings restore with the restore from the scope we're removing\n    for (let current of this.traverse()) {\n      if (\n        current !== node &&\n        node.nodeToRestore &&\n        current.nodeToRestore &&\n        node.scopeRef &&\n        node.scopeRef.current &&\n        isElementInScope(current.nodeToRestore, node.scopeRef.current)\n      ) {\n        current.nodeToRestore = node.nodeToRestore;\n      }\n    }\n    let children = node.children;\n    if (parentNode) {\n      parentNode.removeChild(node);\n      if (children.size > 0) {\n        children.forEach(child => parentNode && parentNode.addChild(child));\n      }\n    }\n\n    this.fastMap.delete(node.scopeRef);\n  }\n\n  // Pre Order Depth First\n  *traverse(node: TreeNode = this.root): Generator<TreeNode> {\n    if (node.scopeRef != null) {\n      yield node;\n    }\n    if (node.children.size > 0) {\n      for (let child of node.children) {\n        yield* this.traverse(child);\n      }\n    }\n  }\n\n  clone(): Tree {\n    let newTree = new Tree();\n    for (let node of this.traverse()) {\n      newTree.addTreeNode(node.scopeRef, node.parent?.scopeRef ?? null, node.nodeToRestore);\n    }\n    return newTree;\n  }\n}\n\nclass TreeNode {\n  public scopeRef: ScopeRef;\n  public nodeToRestore?: FocusableElement;\n  public parent?: TreeNode;\n  public children: Set<TreeNode> = new Set();\n  public contain = false;\n\n  constructor(props: {scopeRef: ScopeRef}) {\n    this.scopeRef = props.scopeRef;\n  }\n  addChild(node: TreeNode) {\n    this.children.add(node);\n    node.parent = this;\n  }\n  removeChild(node: TreeNode) {\n    this.children.delete(node);\n    node.parent = undefined;\n  }\n}\n\nexport let focusScopeTree = new Tree();\n"],"names":[],"version":3,"file":"FocusScope.main.js.map"}
\ No newline at end of file
diff --git a/dist/FocusScope.mjs b/dist/FocusScope.mjs
index 31027ddb3310e93ac6803998cbae3cdedd77f712..66620904e3a7a521ddf8a0785fe5aa21031aae55 100644
--- a/dist/FocusScope.mjs
+++ b/dist/FocusScope.mjs
@@ -1,6 +1,6 @@
 import {focusSafely as $6a99195332edec8b$export$80f3e147d781571c} from "./focusSafely.mjs";
 import {isElementVisible as $645f2e67b85a24c9$export$e989c0fffaa6b27a} from "./isElementVisible.mjs";
-import {useLayoutEffect as $cgawC$useLayoutEffect, getOwnerDocument as $cgawC$getOwnerDocument} from "@react-aria/utils";
+import {useLayoutEffect as $cgawC$useLayoutEffect, getRootNode as $cgawC$getRootNode, getOwnerDocument as $cgawC$getOwnerDocument, getRootBody as $cgawC$getRootBody} from "@react-aria/utils";
 import $cgawC$react, {useRef as $cgawC$useRef, useContext as $cgawC$useContext, useMemo as $cgawC$useMemo, useEffect as $cgawC$useEffect} from "react";
 
 /*
@@ -18,6 +18,7 @@ import $cgawC$react, {useRef as $cgawC$useRef, useContext as $cgawC$useContext,
 
 
 const $9bf71ea28793e738$var$FocusContext = /*#__PURE__*/ (0, $cgawC$react).createContext(null);
+const $9bf71ea28793e738$var$RESTORE_FOCUS_EVENT = 'react-aria-focus-scope-restore';
 let $9bf71ea28793e738$var$activeScope = null;
 function $9bf71ea28793e738$export$20e40289641fbbb6(props) {
     let { children: children, contain: contain, restoreFocus: restoreFocus, autoFocus: autoFocus } = props;
@@ -59,11 +60,17 @@ function $9bf71ea28793e738$export$20e40289641fbbb6(props) {
         // Find all rendered nodes between the sentinels and add them to the scope.
         let node = (_startRef_current = startRef.current) === null || _startRef_current === void 0 ? void 0 : _startRef_current.nextSibling;
         let nodes = [];
+        let stopPropagation = (e)=>e.stopPropagation();
         while(node && node !== endRef.current){
             nodes.push(node);
+            // Stop custom restore focus event from propagating to parent focus scopes.
+            node.addEventListener($9bf71ea28793e738$var$RESTORE_FOCUS_EVENT, stopPropagation);
             node = node.nextSibling;
         }
         scopeRef.current = nodes;
+        return ()=>{
+            for (let node of nodes)node.removeEventListener($9bf71ea28793e738$var$RESTORE_FOCUS_EVENT, stopPropagation);
+        };
     }, [
         children
     ]);
@@ -74,7 +81,8 @@ function $9bf71ea28793e738$export$20e40289641fbbb6(props) {
     // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.
     // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.
     (0, $cgawC$useEffect)(()=>{
-        const activeElement = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined).activeElement;
+        var _getRootNode;
+        const activeElement = (_getRootNode = (0, $cgawC$getRootNode)(scopeRef.current ? scopeRef.current[0] : undefined)) === null || _getRootNode === void 0 ? void 0 : _getRootNode.activeElement;
         let scope = null;
         if ($9bf71ea28793e738$var$isElementInScope(activeElement, scopeRef.current)) {
             // We need to traverse the focusScope tree and find the bottom most scope that
@@ -126,9 +134,10 @@ function $9bf71ea28793e738$export$10c5169755ce7bd7() {
 function $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {
     return {
         focusNext (opts = {}) {
+            var _getRootNode;
             let scope = scopeRef.current;
             let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;
-            let node = from || (0, $cgawC$getOwnerDocument)(scope[0]).activeElement;
+            let node = from || ((_getRootNode = (0, $cgawC$getRootNode)(scope[0])) === null || _getRootNode === void 0 ? void 0 : _getRootNode.activeElement);
             let sentinel = scope[0].previousElementSibling;
             let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
             let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
@@ -145,9 +154,10 @@ function $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {
             return nextNode;
         },
         focusPrevious (opts = {}) {
+            var _getRootNode;
             let scope = scopeRef.current;
             let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;
-            let node = from || (0, $cgawC$getOwnerDocument)(scope[0]).activeElement;
+            let node = from || ((_getRootNode = (0, $cgawC$getRootNode)(scope[0])) === null || _getRootNode === void 0 ? void 0 : _getRootNode.activeElement);
             let sentinel = scope[scope.length - 1].nextElementSibling;
             let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
             let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
@@ -224,8 +234,8 @@ function $9bf71ea28793e738$var$shouldContainFocus(scopeRef) {
     return true;
 }
 function $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {
-    let focusedNode = (0, $cgawC$useRef)();
-    let raf = (0, $cgawC$useRef)();
+    let focusedNode = (0, $cgawC$useRef)(undefined);
+    let raf = (0, $cgawC$useRef)(undefined);
     (0, $cgawC$useLayoutEffect)(()=>{
         let scope = scopeRef.current;
         if (!contain) {
@@ -236,7 +246,7 @@ function $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {
             }
             return;
         }
-        const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
+        const ownerDocument = (0, $cgawC$getRootNode)(scope ? scope[0] : undefined) || (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
         // Handle the Tab key to contain focus within the scope
         let onKeyDown = (e)=>{
             if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef) || e.isComposing) return;
@@ -277,7 +287,7 @@ function $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {
                 // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                 if (ownerDocument.activeElement && $9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(ownerDocument.activeElement, scopeRef)) {
                     $9bf71ea28793e738$var$activeScope = scopeRef;
-                    if (ownerDocument.body.contains(e.target)) {
+                    if ((0, $cgawC$getRootBody)(ownerDocument).contains(e.target)) {
                         var _focusedNode_current;
                         focusedNode.current = e.target;
                         (_focusedNode_current = focusedNode.current) === null || _focusedNode_current === void 0 ? void 0 : _focusedNode_current.focus();
@@ -351,7 +361,7 @@ function $9bf71ea28793e738$var$focusElement(element, scroll = false) {
     // ignore
     }
 }
-function $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {
+function $9bf71ea28793e738$var$getFirstInScope(scope, tabbable = true) {
     let sentinel = scope[0].previousElementSibling;
     let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
     let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
@@ -368,7 +378,10 @@ function $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {
         walker.currentNode = sentinel;
         nextNode = walker.nextNode();
     }
-    $9bf71ea28793e738$var$focusElement(nextNode);
+    return nextNode;
+}
+function $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {
+    $9bf71ea28793e738$var$focusElement($9bf71ea28793e738$var$getFirstInScope(scope, tabbable));
 }
 function $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {
     const autoFocusRef = (0, $cgawC$react).useRef(autoFocus);
@@ -389,7 +402,7 @@ function $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restore, contain)
     (0, $cgawC$useLayoutEffect)(()=>{
         if (restore || contain) return;
         let scope = scopeRef.current;
-        const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
+        const ownerDocument = (0, $cgawC$getRootNode)(scope ? scope[0] : undefined) || (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
         let onFocus = (e)=>{
             let target = e.target;
             if ($9bf71ea28793e738$var$isElementInScope(target, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;
@@ -423,7 +436,7 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
     // restoring-non-containing scopes should only care if they become active so they can perform the restore
     (0, $cgawC$useLayoutEffect)(()=>{
         let scope = scopeRef.current;
-        const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
+        const ownerDocument = (0, $cgawC$getRootNode)(scope ? scope[0] : undefined) || (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
         if (!restoreFocus || contain) return;
         let onFocus = ()=>{
             // If focusing an element in a child scope of the currently active scope, the child becomes active.
@@ -442,7 +455,7 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
         contain
     ]);
     (0, $cgawC$useLayoutEffect)(()=>{
-        const ownerDocument = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
+        const ownerDocument = (0, $cgawC$getRootNode)(scopeRef.current ? scopeRef.current[0] : undefined) || (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
         if (!restoreFocus) return;
         // Handle the Tab key so that tabbing out of the scope goes to the next element
         // after the node that had focus when the scope mounted. This is important when
@@ -455,14 +468,15 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
             let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
             if (!treeNode) return;
             let nodeToRestore = treeNode.nodeToRestore;
+            const rootBody = (0, $cgawC$getRootBody)(ownerDocument);
             // Create a DOM tree walker that matches all tabbable elements
-            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(ownerDocument.body, {
+            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(rootBody, {
                 tabbable: true
             });
             // Find the next tabbable element after the currently focused element
             walker.currentNode = focusedElement;
             let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
-            if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {
+            if (!nodeToRestore || !rootBody.contains(nodeToRestore) || nodeToRestore === rootBody) {
                 nodeToRestore = undefined;
                 treeNode.nodeToRestore = undefined;
             }
@@ -494,7 +508,8 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
     ]);
     // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
     (0, $cgawC$useLayoutEffect)(()=>{
-        const ownerDocument = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
+        const ownerDocument = (0, $cgawC$getRootNode)(scopeRef.current ? scopeRef.current[0] : undefined) || (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
+        const rootBody = (0, $cgawC$getRootBody)(ownerDocument);
         if (!restoreFocus) return;
         let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
         if (!treeNode) return;
@@ -506,17 +521,17 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
             let nodeToRestore = treeNode.nodeToRestore;
             // if we already lost focus to the body and this was the active scope, then we should attempt to restore
             if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
-            ($9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current) || ownerDocument.activeElement === ownerDocument.body && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {
+            ($9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current) || ownerDocument.activeElement === rootBody && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {
                 // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                 let clonedTree = $9bf71ea28793e738$export$d06fae2ee68b101e.clone();
                 requestAnimationFrame(()=>{
                     // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
-                    if (ownerDocument.activeElement === ownerDocument.body) {
+                    if (ownerDocument.activeElement === rootBody) {
                         // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                         let treeNode = clonedTree.getTreeNode(scopeRef);
                         while(treeNode){
                             if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {
-                                $9bf71ea28793e738$var$focusElement(treeNode.nodeToRestore);
+                                $9bf71ea28793e738$var$restoreFocusToElement(treeNode.nodeToRestore);
                                 return;
                             }
                             treeNode = treeNode.parent;
@@ -526,7 +541,8 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
                         treeNode = clonedTree.getTreeNode(scopeRef);
                         while(treeNode){
                             if (treeNode.scopeRef && treeNode.scopeRef.current && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
-                                $9bf71ea28793e738$var$focusFirstInScope(treeNode.scopeRef.current, true);
+                                let node = $9bf71ea28793e738$var$getFirstInScope(treeNode.scopeRef.current, true);
+                                $9bf71ea28793e738$var$restoreFocusToElement(node);
                                 return;
                             }
                             treeNode = treeNode.parent;
@@ -540,9 +556,20 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
         restoreFocus
     ]);
 }
+function $9bf71ea28793e738$var$restoreFocusToElement(node) {
+    // Dispatch a custom event that parent elements can intercept to customize focus restoration.
+    // For example, virtualized collection components reuse DOM elements, so the original element
+    // might still exist in the DOM but representing a different item.
+    if (node.dispatchEvent(new CustomEvent($9bf71ea28793e738$var$RESTORE_FOCUS_EVENT, {
+        bubbles: true,
+        cancelable: true
+    }))) $9bf71ea28793e738$var$focusElement(node);
+}
 function $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {
     let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;
-    let walker = (0, $cgawC$getOwnerDocument)(root).createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
+    let doc = root instanceof ShadowRoot ? root : (0, $cgawC$getRootNode)(root) || (0, $cgawC$getOwnerDocument)(root);
+    let effectiveDocument = doc instanceof ShadowRoot ? doc.ownerDocument : doc;
+    let walker = effectiveDocument.createTreeWalker(root || doc, NodeFilter.SHOW_ELEMENT, {
         acceptNode (node) {
             var _opts_from;
             // Skip nodes inside the starting node.
@@ -552,6 +579,12 @@ function $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {
         }
     });
     if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
+    if (doc instanceof ShadowRoot) {
+        const originalNextNode = walker.nextNode.bind(walker);
+        const originalPreviousNode = walker.previousNode.bind(walker);
+        walker.nextNode = $9bf71ea28793e738$var$getNextShadowNode(originalNextNode, scope);
+        walker.previousNode = $9bf71ea28793e738$var$getPreviousShadowNode(originalPreviousNode, scope);
+    }
     return walker;
 }
 function $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {
@@ -560,7 +593,7 @@ function $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {
             let root = ref.current;
             if (!root) return null;
             let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;
-            let node = from || (0, $cgawC$getOwnerDocument)(root).activeElement;
+            let node = from || ((0, $cgawC$getRootNode)(root) || (0, $cgawC$getOwnerDocument)(root)).activeElement;
             let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
                 tabbable: tabbable,
                 accept: accept
@@ -578,7 +611,7 @@ function $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {
             let root = ref.current;
             if (!root) return null;
             let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;
-            let node = from || (0, $cgawC$getOwnerDocument)(root).activeElement;
+            let node = from || ((0, $cgawC$getRootNode)(root) || (0, $cgawC$getOwnerDocument)(root)).activeElement;
             let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
                 tabbable: tabbable,
                 accept: accept
@@ -635,6 +668,40 @@ function $9bf71ea28793e738$var$last(walker) {
     }while (last);
     return next;
 }
+function $9bf71ea28793e738$var$getNextShadowNode(originalNextNode, scope) {
+    return function() {
+        let nextElement = originalNextNode();
+        if (!nextElement && scope && scope.length > 0) {
+            let currentShadowRoot = scope[0].getRootNode();
+            let nextShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.nextElementSibling : null;
+            while(nextShadowHost){
+                if (nextShadowHost.shadowRoot) {
+                    let nextShadowScope = Array.from(nextShadowHost.shadowRoot.querySelectorAll('*')).filter($9bf71ea28793e738$export$4c063cf1350e6fed);
+                    if (nextShadowScope.length > 0) return nextShadowScope[0];
+                }
+                nextShadowHost = nextShadowHost.nextElementSibling;
+            }
+        }
+        return nextElement;
+    };
+}
+function $9bf71ea28793e738$var$getPreviousShadowNode(originalPreviousNode, scope) {
+    return function() {
+        let previousElement = originalPreviousNode();
+        if (!previousElement && scope && scope.length > 0) {
+            let currentShadowRoot = scope[0].getRootNode();
+            let previousShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.previousElementSibling : null;
+            while(previousShadowHost){
+                if (previousShadowHost.shadowRoot) {
+                    let previousShadowScope = Array.from(previousShadowHost.shadowRoot.querySelectorAll('*')).filter($9bf71ea28793e738$export$4c063cf1350e6fed);
+                    if (previousShadowScope.length > 0) return previousShadowScope[previousShadowScope.length - 1];
+                }
+                previousShadowHost = previousShadowHost.previousElementSibling;
+            }
+        }
+        return previousElement;
+    };
+}
 class $9bf71ea28793e738$var$Tree {
     get size() {
         return this.fastMap.size;
diff --git a/dist/FocusScope.module.js b/dist/FocusScope.module.js
index c8dc7fd310962631c275472354b34e353e16aaef..b1692688fe07d852367628325dd9a4a598f243dc 100644
--- a/dist/FocusScope.module.js
+++ b/dist/FocusScope.module.js
@@ -1,6 +1,6 @@
 import {focusSafely as $6a99195332edec8b$export$80f3e147d781571c} from "./focusSafely.module.js";
 import {isElementVisible as $645f2e67b85a24c9$export$e989c0fffaa6b27a} from "./isElementVisible.module.js";
-import {useLayoutEffect as $cgawC$useLayoutEffect, getOwnerDocument as $cgawC$getOwnerDocument} from "@react-aria/utils";
+import {useLayoutEffect as $cgawC$useLayoutEffect, getRootNode as $cgawC$getRootNode, getOwnerDocument as $cgawC$getOwnerDocument, getRootBody as $cgawC$getRootBody} from "@react-aria/utils";
 import $cgawC$react, {useRef as $cgawC$useRef, useContext as $cgawC$useContext, useMemo as $cgawC$useMemo, useEffect as $cgawC$useEffect} from "react";
 
 /*
@@ -18,6 +18,7 @@ import $cgawC$react, {useRef as $cgawC$useRef, useContext as $cgawC$useContext,
 
 
 const $9bf71ea28793e738$var$FocusContext = /*#__PURE__*/ (0, $cgawC$react).createContext(null);
+const $9bf71ea28793e738$var$RESTORE_FOCUS_EVENT = 'react-aria-focus-scope-restore';
 let $9bf71ea28793e738$var$activeScope = null;
 function $9bf71ea28793e738$export$20e40289641fbbb6(props) {
     let { children: children, contain: contain, restoreFocus: restoreFocus, autoFocus: autoFocus } = props;
@@ -59,11 +60,17 @@ function $9bf71ea28793e738$export$20e40289641fbbb6(props) {
         // Find all rendered nodes between the sentinels and add them to the scope.
         let node = (_startRef_current = startRef.current) === null || _startRef_current === void 0 ? void 0 : _startRef_current.nextSibling;
         let nodes = [];
+        let stopPropagation = (e)=>e.stopPropagation();
         while(node && node !== endRef.current){
             nodes.push(node);
+            // Stop custom restore focus event from propagating to parent focus scopes.
+            node.addEventListener($9bf71ea28793e738$var$RESTORE_FOCUS_EVENT, stopPropagation);
             node = node.nextSibling;
         }
         scopeRef.current = nodes;
+        return ()=>{
+            for (let node of nodes)node.removeEventListener($9bf71ea28793e738$var$RESTORE_FOCUS_EVENT, stopPropagation);
+        };
     }, [
         children
     ]);
@@ -74,7 +81,8 @@ function $9bf71ea28793e738$export$20e40289641fbbb6(props) {
     // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.
     // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.
     (0, $cgawC$useEffect)(()=>{
-        const activeElement = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined).activeElement;
+        var _getRootNode;
+        const activeElement = (_getRootNode = (0, $cgawC$getRootNode)(scopeRef.current ? scopeRef.current[0] : undefined)) === null || _getRootNode === void 0 ? void 0 : _getRootNode.activeElement;
         let scope = null;
         if ($9bf71ea28793e738$var$isElementInScope(activeElement, scopeRef.current)) {
             // We need to traverse the focusScope tree and find the bottom most scope that
@@ -126,9 +134,10 @@ function $9bf71ea28793e738$export$10c5169755ce7bd7() {
 function $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {
     return {
         focusNext (opts = {}) {
+            var _getRootNode;
             let scope = scopeRef.current;
             let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;
-            let node = from || (0, $cgawC$getOwnerDocument)(scope[0]).activeElement;
+            let node = from || ((_getRootNode = (0, $cgawC$getRootNode)(scope[0])) === null || _getRootNode === void 0 ? void 0 : _getRootNode.activeElement);
             let sentinel = scope[0].previousElementSibling;
             let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
             let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
@@ -145,9 +154,10 @@ function $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {
             return nextNode;
         },
         focusPrevious (opts = {}) {
+            var _getRootNode;
             let scope = scopeRef.current;
             let { from: from, tabbable: tabbable, wrap: wrap, accept: accept } = opts;
-            let node = from || (0, $cgawC$getOwnerDocument)(scope[0]).activeElement;
+            let node = from || ((_getRootNode = (0, $cgawC$getRootNode)(scope[0])) === null || _getRootNode === void 0 ? void 0 : _getRootNode.activeElement);
             let sentinel = scope[scope.length - 1].nextElementSibling;
             let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
             let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
@@ -224,8 +234,8 @@ function $9bf71ea28793e738$var$shouldContainFocus(scopeRef) {
     return true;
 }
 function $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {
-    let focusedNode = (0, $cgawC$useRef)();
-    let raf = (0, $cgawC$useRef)();
+    let focusedNode = (0, $cgawC$useRef)(undefined);
+    let raf = (0, $cgawC$useRef)(undefined);
     (0, $cgawC$useLayoutEffect)(()=>{
         let scope = scopeRef.current;
         if (!contain) {
@@ -236,7 +246,7 @@ function $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {
             }
             return;
         }
-        const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
+        const ownerDocument = (0, $cgawC$getRootNode)(scope ? scope[0] : undefined) || (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
         // Handle the Tab key to contain focus within the scope
         let onKeyDown = (e)=>{
             if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef) || e.isComposing) return;
@@ -277,7 +287,7 @@ function $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {
                 // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
                 if (ownerDocument.activeElement && $9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(ownerDocument.activeElement, scopeRef)) {
                     $9bf71ea28793e738$var$activeScope = scopeRef;
-                    if (ownerDocument.body.contains(e.target)) {
+                    if ((0, $cgawC$getRootBody)(ownerDocument).contains(e.target)) {
                         var _focusedNode_current;
                         focusedNode.current = e.target;
                         (_focusedNode_current = focusedNode.current) === null || _focusedNode_current === void 0 ? void 0 : _focusedNode_current.focus();
@@ -351,7 +361,7 @@ function $9bf71ea28793e738$var$focusElement(element, scroll = false) {
     // ignore
     }
 }
-function $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {
+function $9bf71ea28793e738$var$getFirstInScope(scope, tabbable = true) {
     let sentinel = scope[0].previousElementSibling;
     let scopeRoot = $9bf71ea28793e738$var$getScopeRoot(scope);
     let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(scopeRoot, {
@@ -368,7 +378,10 @@ function $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {
         walker.currentNode = sentinel;
         nextNode = walker.nextNode();
     }
-    $9bf71ea28793e738$var$focusElement(nextNode);
+    return nextNode;
+}
+function $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {
+    $9bf71ea28793e738$var$focusElement($9bf71ea28793e738$var$getFirstInScope(scope, tabbable));
 }
 function $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {
     const autoFocusRef = (0, $cgawC$react).useRef(autoFocus);
@@ -389,7 +402,7 @@ function $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restore, contain)
     (0, $cgawC$useLayoutEffect)(()=>{
         if (restore || contain) return;
         let scope = scopeRef.current;
-        const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
+        const ownerDocument = (0, $cgawC$getRootNode)(scope ? scope[0] : undefined) || (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
         let onFocus = (e)=>{
             let target = e.target;
             if ($9bf71ea28793e738$var$isElementInScope(target, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;
@@ -423,7 +436,7 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
     // restoring-non-containing scopes should only care if they become active so they can perform the restore
     (0, $cgawC$useLayoutEffect)(()=>{
         let scope = scopeRef.current;
-        const ownerDocument = (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
+        const ownerDocument = (0, $cgawC$getRootNode)(scope ? scope[0] : undefined) || (0, $cgawC$getOwnerDocument)(scope ? scope[0] : undefined);
         if (!restoreFocus || contain) return;
         let onFocus = ()=>{
             // If focusing an element in a child scope of the currently active scope, the child becomes active.
@@ -442,7 +455,7 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
         contain
     ]);
     (0, $cgawC$useLayoutEffect)(()=>{
-        const ownerDocument = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
+        const ownerDocument = (0, $cgawC$getRootNode)(scopeRef.current ? scopeRef.current[0] : undefined) || (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
         if (!restoreFocus) return;
         // Handle the Tab key so that tabbing out of the scope goes to the next element
         // after the node that had focus when the scope mounted. This is important when
@@ -455,14 +468,15 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
             let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
             if (!treeNode) return;
             let nodeToRestore = treeNode.nodeToRestore;
+            const rootBody = (0, $cgawC$getRootBody)(ownerDocument);
             // Create a DOM tree walker that matches all tabbable elements
-            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(ownerDocument.body, {
+            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(rootBody, {
                 tabbable: true
             });
             // Find the next tabbable element after the currently focused element
             walker.currentNode = focusedElement;
             let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();
-            if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {
+            if (!nodeToRestore || !rootBody.contains(nodeToRestore) || nodeToRestore === rootBody) {
                 nodeToRestore = undefined;
                 treeNode.nodeToRestore = undefined;
             }
@@ -494,7 +508,8 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
     ]);
     // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
     (0, $cgawC$useLayoutEffect)(()=>{
-        const ownerDocument = (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
+        const ownerDocument = (0, $cgawC$getRootNode)(scopeRef.current ? scopeRef.current[0] : undefined) || (0, $cgawC$getOwnerDocument)(scopeRef.current ? scopeRef.current[0] : undefined);
+        const rootBody = (0, $cgawC$getRootBody)(ownerDocument);
         if (!restoreFocus) return;
         let treeNode = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);
         if (!treeNode) return;
@@ -506,17 +521,17 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
             let nodeToRestore = treeNode.nodeToRestore;
             // if we already lost focus to the body and this was the active scope, then we should attempt to restore
             if (restoreFocus && nodeToRestore && // eslint-disable-next-line react-hooks/exhaustive-deps
-            ($9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current) || ownerDocument.activeElement === ownerDocument.body && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {
+            ($9bf71ea28793e738$var$isElementInScope(ownerDocument.activeElement, scopeRef.current) || ownerDocument.activeElement === rootBody && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {
                 // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
                 let clonedTree = $9bf71ea28793e738$export$d06fae2ee68b101e.clone();
                 requestAnimationFrame(()=>{
                     // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
-                    if (ownerDocument.activeElement === ownerDocument.body) {
+                    if (ownerDocument.activeElement === rootBody) {
                         // look up the tree starting with our scope to find a nodeToRestore still in the DOM
                         let treeNode = clonedTree.getTreeNode(scopeRef);
                         while(treeNode){
                             if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {
-                                $9bf71ea28793e738$var$focusElement(treeNode.nodeToRestore);
+                                $9bf71ea28793e738$var$restoreFocusToElement(treeNode.nodeToRestore);
                                 return;
                             }
                             treeNode = treeNode.parent;
@@ -526,7 +541,8 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
                         treeNode = clonedTree.getTreeNode(scopeRef);
                         while(treeNode){
                             if (treeNode.scopeRef && treeNode.scopeRef.current && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {
-                                $9bf71ea28793e738$var$focusFirstInScope(treeNode.scopeRef.current, true);
+                                let node = $9bf71ea28793e738$var$getFirstInScope(treeNode.scopeRef.current, true);
+                                $9bf71ea28793e738$var$restoreFocusToElement(node);
                                 return;
                             }
                             treeNode = treeNode.parent;
@@ -540,9 +556,20 @@ function $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain)
         restoreFocus
     ]);
 }
+function $9bf71ea28793e738$var$restoreFocusToElement(node) {
+    // Dispatch a custom event that parent elements can intercept to customize focus restoration.
+    // For example, virtualized collection components reuse DOM elements, so the original element
+    // might still exist in the DOM but representing a different item.
+    if (node.dispatchEvent(new CustomEvent($9bf71ea28793e738$var$RESTORE_FOCUS_EVENT, {
+        bubbles: true,
+        cancelable: true
+    }))) $9bf71ea28793e738$var$focusElement(node);
+}
 function $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {
     let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;
-    let walker = (0, $cgawC$getOwnerDocument)(root).createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
+    let doc = root instanceof ShadowRoot ? root : (0, $cgawC$getRootNode)(root) || (0, $cgawC$getOwnerDocument)(root);
+    let effectiveDocument = doc instanceof ShadowRoot ? doc.ownerDocument : doc;
+    let walker = effectiveDocument.createTreeWalker(root || doc, NodeFilter.SHOW_ELEMENT, {
         acceptNode (node) {
             var _opts_from;
             // Skip nodes inside the starting node.
@@ -552,6 +579,12 @@ function $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {
         }
     });
     if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;
+    if (doc instanceof ShadowRoot) {
+        const originalNextNode = walker.nextNode.bind(walker);
+        const originalPreviousNode = walker.previousNode.bind(walker);
+        walker.nextNode = $9bf71ea28793e738$var$getNextShadowNode(originalNextNode, scope);
+        walker.previousNode = $9bf71ea28793e738$var$getPreviousShadowNode(originalPreviousNode, scope);
+    }
     return walker;
 }
 function $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {
@@ -560,7 +593,7 @@ function $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {
             let root = ref.current;
             if (!root) return null;
             let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;
-            let node = from || (0, $cgawC$getOwnerDocument)(root).activeElement;
+            let node = from || ((0, $cgawC$getRootNode)(root) || (0, $cgawC$getOwnerDocument)(root)).activeElement;
             let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
                 tabbable: tabbable,
                 accept: accept
@@ -578,7 +611,7 @@ function $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {}) {
             let root = ref.current;
             if (!root) return null;
             let { from: from, tabbable: tabbable = defaultOptions.tabbable, wrap: wrap = defaultOptions.wrap, accept: accept = defaultOptions.accept } = opts;
-            let node = from || (0, $cgawC$getOwnerDocument)(root).activeElement;
+            let node = from || ((0, $cgawC$getRootNode)(root) || (0, $cgawC$getOwnerDocument)(root)).activeElement;
             let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {
                 tabbable: tabbable,
                 accept: accept
@@ -635,6 +668,40 @@ function $9bf71ea28793e738$var$last(walker) {
     }while (last);
     return next;
 }
+function $9bf71ea28793e738$var$getNextShadowNode(originalNextNode, scope) {
+    return function() {
+        let nextElement = originalNextNode();
+        if (!nextElement && scope && scope.length > 0) {
+            let currentShadowRoot = scope[0].getRootNode();
+            let nextShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.nextElementSibling : null;
+            while(nextShadowHost){
+                if (nextShadowHost.shadowRoot) {
+                    let nextShadowScope = Array.from(nextShadowHost.shadowRoot.querySelectorAll('*')).filter($9bf71ea28793e738$export$4c063cf1350e6fed);
+                    if (nextShadowScope.length > 0) return nextShadowScope[0];
+                }
+                nextShadowHost = nextShadowHost.nextElementSibling;
+            }
+        }
+        return nextElement;
+    };
+}
+function $9bf71ea28793e738$var$getPreviousShadowNode(originalPreviousNode, scope) {
+    return function() {
+        let previousElement = originalPreviousNode();
+        if (!previousElement && scope && scope.length > 0) {
+            let currentShadowRoot = scope[0].getRootNode();
+            let previousShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.previousElementSibling : null;
+            while(previousShadowHost){
+                if (previousShadowHost.shadowRoot) {
+                    let previousShadowScope = Array.from(previousShadowHost.shadowRoot.querySelectorAll('*')).filter($9bf71ea28793e738$export$4c063cf1350e6fed);
+                    if (previousShadowScope.length > 0) return previousShadowScope[previousShadowScope.length - 1];
+                }
+                previousShadowHost = previousShadowHost.previousElementSibling;
+            }
+        }
+        return previousElement;
+    };
+}
 class $9bf71ea28793e738$var$Tree {
     get size() {
         return this.fastMap.size;
diff --git a/dist/FocusScope.module.js.map b/dist/FocusScope.module.js.map
index 4f928ae1cd9ba6bc0893b17f88bbf4dfeae3f3a8..aa6dfe0322eea01249fa17d9de48a29cd0ab1b71 100644
--- a/dist/FocusScope.module.js.map
+++ b/dist/FocusScope.module.js.map
@@ -1 +1 @@
-{"mappings":";;;;;AAAA;;;;;;;;;;CAUC;;;;AAwDD,MAAM,mDAAe,CAAA,GAAA,YAAI,EAAE,aAAa,CAAuB;AAE/D,IAAI,oCAAwB;AAYrB,SAAS,0CAAW,KAAsB;IAC/C,IAAI,YAAC,QAAQ,WAAE,OAAO,gBAAE,YAAY,aAAE,SAAS,EAAC,GAAG;IACnD,IAAI,WAAW,CAAA,GAAA,aAAK,EAAmB;IACvC,IAAI,SAAS,CAAA,GAAA,aAAK,EAAmB;IACrC,IAAI,WAAW,CAAA,GAAA,aAAK,EAAa,EAAE;IACnC,IAAI,cAAC,UAAU,EAAC,GAAG,CAAA,GAAA,iBAAS,EAAE,uCAAiB,CAAC;IAEhD,4FAA4F;IAC5F,IAAI,OAAO,CAAA,GAAA,cAAM,EAAE,IAAM,IAAI,+BAAS;sBAAC;QAAQ,IAAI;QAAC;KAAS;IAE7D,CAAA,GAAA,sBAAc,EAAE;QACd,+FAA+F;QAC/F,mGAAmG;QACnG,mGAAmG;QACnG,gEAAgE;QAChE,IAAI,SAAS,cAAc,0CAAe,IAAI;QAC9C,IAAI,0CAAe,WAAW,CAAC,OAAO,QAAQ,KAAK,qCAAe,CAAC,sCAAgB,mCAAa,OAAO,QAAQ,GAAG;YAChH,IAAI,aAAa,0CAAe,WAAW,CAAC;YAC5C,IAAI,YACF,SAAS;QAEb;QAEA,+CAA+C;QAC/C,OAAO,QAAQ,CAAC;QAChB,0CAAe,OAAO,CAAC;IACzB,GAAG;QAAC;QAAM;KAAW;IAErB,CAAA,GAAA,sBAAc,EAAE;QACd,IAAI,OAAO,0CAAe,WAAW,CAAC;QACtC,IAAI,MACF,KAAK,OAAO,GAAG,CAAC,CAAC;IAErB,GAAG;QAAC;KAAQ;IAEZ,CAAA,GAAA,sBAAc,EAAE;YAEH;QADX,2EAA2E;QAC3E,IAAI,QAAO,oBAAA,SAAS,OAAO,cAAhB,wCAAA,kBAAkB,WAAW;QACxC,IAAI,QAAmB,EAAE;QACzB,MAAO,QAAQ,SAAS,OAAO,OAAO,CAAE;YACtC,MAAM,IAAI,CAAC;YACX,OAAO,KAAK,WAAW;QACzB;QAEA,SAAS,OAAO,GAAG;IACrB,GAAG;QAAC;KAAS;IAEb,4CAAsB,UAAU,cAAc;IAC9C,0CAAoB,UAAU;IAC9B,sCAAgB,UAAU,cAAc;IACxC,mCAAa,UAAU;IAEvB,mGAAmG;IACnG,uGAAuG;IACvG,CAAA,GAAA,gBAAQ,EAAE;QACR,MAAM,gBAAgB,CAAA,GAAA,uBAAe,EAAE,SAAS,OAAO,GAAG,SAAS,OAAO,CAAC,EAAE,GAAG,WAAW,aAAa;QACxG,IAAI,QAAyB;QAE7B,IAAI,uCAAiB,eAAe,SAAS,OAAO,GAAG;YACrD,8EAA8E;YAC9E,+DAA+D;YAC/D,KAAK,IAAI,QAAQ,0CAAe,QAAQ,GACtC,IAAI,KAAK,QAAQ,IAAI,uCAAiB,eAAe,KAAK,QAAQ,CAAC,OAAO,GACxE,QAAQ;YAIZ,IAAI,UAAU,0CAAe,WAAW,CAAC,WACvC,oCAAc,MAAM,QAAQ;QAEhC;IACF,GAAG;QAAC;KAAS;IAEb,yGAAyG;IACzG,mCAAmC;IACnC,CAAA,GAAA,sBAAc,EAAE;QACd,OAAO;gBAEa,oCAAA;gBAAA;YADlB,mCAAmC;YACnC,IAAI,cAAc,CAAA,+CAAA,8BAAA,0CAAe,WAAW,CAAC,uBAA3B,mDAAA,qCAAA,4BAAsC,MAAM,cAA5C,yDAAA,mCAA8C,QAAQ,cAAtD,yDAAA,8CAA0D;YAE5E,IACE,AAAC,CAAA,aAAa,qCAAe,sCAAgB,UAAU,kCAAW,KACjE,CAAA,CAAC,eAAe,0CAAe,WAAW,CAAC,YAAW,GAEvD,oCAAc;YAEhB,0CAAe,cAAc,CAAC;QAChC;IACF,GAAG;QAAC;KAAS;IAEb,IAAI,eAAe,CAAA,GAAA,cAAM,EAAE,IAAM,iDAA2B,WAAW,EAAE;IACzE,IAAI,QAAQ,CAAA,GAAA,cAAM,EAAE,IAAO,CAAA;0BACzB;YACA,YAAY;QACd,CAAA,GAAI;QAAC;QAAM;KAAa;IAExB,qBACE,gCAAC,mCAAa,QAAQ;QAAC,OAAO;qBAC5B,gCAAC;QAAK,0BAAA;QAAuB,QAAA;QAAO,KAAK;QACxC,wBACD,gCAAC;QAAK,wBAAA;QAAqB,QAAA;QAAO,KAAK;;AAG7C;AAOO,SAAS;QACP;IAAP,QAAO,cAAA,CAAA,GAAA,iBAAS,EAAE,iDAAX,kCAAA,YAA0B,YAAY;AAC/C;AAEA,SAAS,iDAA2B,QAAoC;IACtE,OAAO;QACL,WAAU,OAA4B,CAAC,CAAC;YACtC,IAAI,QAAQ,SAAS,OAAO;YAC5B,IAAI,QAAC,IAAI,YAAE,QAAQ,QAAE,IAAI,UAAE,MAAM,EAAC,GAAG;YACrC,IAAI,OAAO,QAAQ,CAAA,GAAA,uBAAe,EAAE,KAAK,CAAC,EAAE,EAAE,aAAa;YAC3D,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC,sBAAsB;YAC9C,IAAI,YAAY,mCAAa;YAC7B,IAAI,SAAS,0CAAuB,WAAW;0BAAC;wBAAU;YAAM,GAAG;YACnE,OAAO,WAAW,GAAG,uCAAiB,MAAM,SAAS,OAAO;YAC5D,IAAI,WAAW,OAAO,QAAQ;YAC9B,IAAI,CAAC,YAAY,MAAM;gBACrB,OAAO,WAAW,GAAG;gBACrB,WAAW,OAAO,QAAQ;YAC5B;YACA,IAAI,UACF,mCAAa,UAAU;YAEzB,OAAO;QACT;QACA,eAAc,OAA4B,CAAC,CAAC;YAC1C,IAAI,QAAQ,SAAS,OAAO;YAC5B,IAAI,QAAC,IAAI,YAAE,QAAQ,QAAE,IAAI,UAAE,MAAM,EAAC,GAAG;YACrC,IAAI,OAAO,QAAQ,CAAA,GAAA,uBAAe,EAAE,KAAK,CAAC,EAAE,EAAE,aAAa;YAC3D,IAAI,WAAW,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,CAAC,kBAAkB;YACzD,IAAI,YAAY,mCAAa;YAC7B,IAAI,SAAS,0CAAuB,WAAW;0BAAC;wBAAU;YAAM,GAAG;YACnE,OAAO,WAAW,GAAG,uCAAiB,MAAM,SAAS,OAAO;YAC5D,IAAI,eAAe,OAAO,YAAY;YACtC,IAAI,CAAC,gBAAgB,MAAM;gBACzB,OAAO,WAAW,GAAG;gBACrB,eAAe,OAAO,YAAY;YACpC;YACA,IAAI,cACF,mCAAa,cAAc;YAE7B,OAAO;QACT;QACA,YAAW,OAAO,CAAC,CAAC;YAClB,IAAI,QAAQ,SAAS,OAAO;YAC5B,IAAI,YAAC,QAAQ,UAAE,MAAM,EAAC,GAAG;YACzB,IAAI,YAAY,mCAAa;YAC7B,IAAI,SAAS,0CAAuB,WAAW;0BAAC;wBAAU;YAAM,GAAG;YACnE,OAAO,WAAW,GAAG,KAAK,CAAC,EAAE,CAAC,sBAAsB;YACpD,IAAI,WAAW,OAAO,QAAQ;YAC9B,IAAI,UACF,mCAAa,UAAU;YAEzB,OAAO;QACT;QACA,WAAU,OAAO,CAAC,CAAC;YACjB,IAAI,QAAQ,SAAS,OAAO;YAC5B,IAAI,YAAC,QAAQ,UAAE,MAAM,EAAC,GAAG;YACzB,IAAI,YAAY,mCAAa;YAC7B,IAAI,SAAS,0CAAuB,WAAW;0BAAC;wBAAU;YAAM,GAAG;YACnE,OAAO,WAAW,GAAG,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,CAAC,kBAAkB;YAC/D,IAAI,eAAe,OAAO,YAAY;YACtC,IAAI,cACF,mCAAa,cAAc;YAE7B,OAAO;QACT;IACF;AACF;AAEA,MAAM,0CAAoB;IACxB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,MAAM,mDAA6B,wCAAkB,IAAI,CAAC,qBAAqB;AAE/E,wCAAkB,IAAI,CAAC;AACvB,MAAM,kDAA4B,wCAAkB,IAAI,CAAC;AAElD,SAAS,0CAAY,OAAoB;IAC9C,OAAO,QAAQ,OAAO,CAAC;AACzB;AAEA,SAAS,mCAAa,KAAgB;IACpC,OAAO,KAAK,CAAC,EAAE,CAAC,aAAa;AAC/B;AAEA,SAAS,yCAAmB,QAAkB;IAC5C,IAAI,QAAQ,0CAAe,WAAW,CAAC;IACvC,MAAO,SAAS,MAAM,QAAQ,KAAK,SAAU;QAC3C,IAAI,MAAM,OAAO,EACf,OAAO;QAGT,QAAQ,MAAM,MAAM;IACtB;IAEA,OAAO;AACT;AAEA,SAAS,0CAAoB,QAA8B,EAAE,OAAiB;IAC5E,IAAI,cAAc,CAAA,GAAA,aAAK;IAEvB,IAAI,MAAM,CAAA,GAAA,aAAK;IACf,CAAA,GAAA,sBAAc,EAAE;QACd,IAAI,QAAQ,SAAS,OAAO;QAC5B,IAAI,CAAC,SAAS;YACZ,sGAAsG;YACtG,IAAI,IAAI,OAAO,EAAE;gBACf,qBAAqB,IAAI,OAAO;gBAChC,IAAI,OAAO,GAAG;YAChB;YACA;QACF;QAEA,MAAM,gBAAgB,CAAA,GAAA,uBAAe,EAAE,QAAQ,KAAK,CAAC,EAAE,GAAG;QAE1D,uDAAuD;QACvD,IAAI,YAAY,CAAC;YACf,IAAI,EAAE,GAAG,KAAK,SAAS,EAAE,MAAM,IAAI,EAAE,OAAO,IAAI,EAAE,OAAO,IAAI,CAAC,yCAAmB,aAAa,EAAE,WAAW,EACzG;YAGF,IAAI,iBAAiB,cAAc,aAAa;YAChD,IAAI,QAAQ,SAAS,OAAO;YAC5B,IAAI,CAAC,SAAS,CAAC,uCAAiB,gBAAgB,QAC9C;YAGF,IAAI,YAAY,mCAAa;YAC7B,IAAI,SAAS,0CAAuB,WAAW;gBAAC,UAAU;YAAI,GAAG;YACjE,IAAI,CAAC,gBACH;YAEF,OAAO,WAAW,GAAG;YACrB,IAAI,cAAe,EAAE,QAAQ,GAAG,OAAO,YAAY,KAAK,OAAO,QAAQ;YACvE,IAAI,CAAC,aAAa;gBAChB,OAAO,WAAW,GAAG,EAAE,QAAQ,GAAG,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,CAAC,kBAAkB,GAAI,KAAK,CAAC,EAAE,CAAC,sBAAsB;gBAC/G,cAAe,EAAE,QAAQ,GAAG,OAAO,YAAY,KAAK,OAAO,QAAQ;YACrE;YAEA,EAAE,cAAc;YAChB,IAAI,aACF,mCAAa,aAAa;QAE9B;QAEA,IAAI,UAAU,CAAC;YACb,mGAAmG;YACnG,gEAAgE;YAChE,IAAI,AAAC,CAAA,CAAC,qCAAe,sCAAgB,mCAAa,SAAQ,KAAM,uCAAiB,EAAE,MAAM,EAAE,SAAS,OAAO,GAAG;gBAC5G,oCAAc;gBACd,YAAY,OAAO,GAAG,EAAE,MAAM;YAChC,OAAO,IAAI,yCAAmB,aAAa,CAAC,4CAAsB,EAAE,MAAM,EAAE,WAAW;gBACrF,+FAA+F;gBAC/F,kGAAkG;gBAClG,IAAI,YAAY,OAAO,EACrB,YAAY,OAAO,CAAC,KAAK;qBACpB,IAAI,qCAAe,kCAAY,OAAO,EAC3C,wCAAkB,kCAAY,OAAO;YAEzC,OAAO,IAAI,yCAAmB,WAC5B,YAAY,OAAO,GAAG,EAAE,MAAM;QAElC;QAEA,IAAI,SAAS,CAAC;YACZ,uEAAuE;YACvE,IAAI,IAAI,OAAO,EACb,qBAAqB,IAAI,OAAO;YAElC,IAAI,OAAO,GAAG,sBAAsB;gBAClC,mGAAmG;gBACnG,IAAI,cAAc,aAAa,IAAI,yCAAmB,aAAa,CAAC,4CAAsB,cAAc,aAAa,EAAE,WAAW;oBAChI,oCAAc;oBACd,IAAI,cAAc,IAAI,CAAC,QAAQ,CAAC,EAAE,MAAM,GAAG;4BAEzC;wBADA,YAAY,OAAO,GAAG,EAAE,MAAM;yBAC9B,uBAAA,YAAY,OAAO,cAAnB,2CAAA,qBAAqB,KAAK;oBAC5B,OAAO,IAAI,kCAAY,OAAO,EAC5B,wCAAkB,kCAAY,OAAO;gBAEzC;YACF;QACF;QAEA,cAAc,gBAAgB,CAAC,WAAW,WAAW;QACrD,cAAc,gBAAgB,CAAC,WAAW,SAAS;QACnD,kBAAA,4BAAA,MAAO,OAAO,CAAC,CAAA,UAAW,QAAQ,gBAAgB,CAAC,WAAW,SAAS;QACvE,kBAAA,4BAAA,MAAO,OAAO,CAAC,CAAA,UAAW,QAAQ,gBAAgB,CAAC,YAAY,QAAQ;QACvE,OAAO;YACL,cAAc,mBAAmB,CAAC,WAAW,WAAW;YACxD,cAAc,mBAAmB,CAAC,WAAW,SAAS;YACtD,kBAAA,4BAAA,MAAO,OAAO,CAAC,CAAA,UAAW,QAAQ,mBAAmB,CAAC,WAAW,SAAS;YAC1E,kBAAA,4BAAA,MAAO,OAAO,CAAC,CAAA,UAAW,QAAQ,mBAAmB,CAAC,YAAY,QAAQ;QAC5E;IACF,GAAG;QAAC;QAAU;KAAQ;IAEtB,uFAAuF;IACvF,4CAA4C;IAC5C,CAAA,GAAA,sBAAc,EAAE;QACd,OAAO;YACL,IAAI,IAAI,OAAO,EACb,qBAAqB,IAAI,OAAO;QAEpC;IACF,GAAG;QAAC;KAAI;AACV;AAEA,SAAS,0CAAoB,OAAgB;IAC3C,OAAO,4CAAsB;AAC/B;AAEA,SAAS,uCAAiB,OAAwB,EAAE,KAAwB;IAC1E,IAAI,CAAC,SACH,OAAO;IAET,IAAI,CAAC,OACH,OAAO;IAET,OAAO,MAAM,IAAI,CAAC,CAAA,OAAQ,KAAK,QAAQ,CAAC;AAC1C;AAEA,SAAS,4CAAsB,OAAgB,EAAE,QAAkB,IAAI;IACrE,+FAA+F;IAC/F,IAAI,mBAAmB,WAAW,QAAQ,OAAO,CAAC,gCAChD,OAAO;IAGT,oFAAoF;IACpF,8CAA8C;IAC9C,KAAK,IAAI,EAAC,UAAU,CAAC,EAAC,IAAI,0CAAe,QAAQ,CAAC,0CAAe,WAAW,CAAC,QAAS;QACpF,IAAI,KAAK,uCAAiB,SAAS,EAAE,OAAO,GAC1C,OAAO;IAEX;IAEA,OAAO;AACT;AAGO,SAAS,0CAA8B,OAAgB;IAC5D,OAAO,4CAAsB,SAAS;AACxC;AAEA,SAAS,sCAAgB,QAAkB,EAAE,KAAe;QAC7C;IAAb,IAAI,UAAS,8BAAA,0CAAe,WAAW,CAAC,oBAA3B,kDAAA,4BAAmC,MAAM;IACtD,MAAO,OAAQ;QACb,IAAI,OAAO,QAAQ,KAAK,UACtB,OAAO;QAET,SAAS,OAAO,MAAM;IACxB;IACA,OAAO;AACT;AAEA,SAAS,mCAAa,OAAgC,EAAE,SAAS,KAAK;IACpE,IAAI,WAAW,QAAQ,CAAC,QACtB,IAAI;QACF,CAAA,GAAA,yCAAU,EAAE;IACd,EAAE,OAAO,KAAK;IACZ,SAAS;IACX;SACK,IAAI,WAAW,MACpB,IAAI;QACF,QAAQ,KAAK;IACf,EAAE,OAAO,KAAK;IACZ,SAAS;IACX;AAEJ;AAEA,SAAS,wCAAkB,KAAgB,EAAE,WAAmB,IAAI;IAClE,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC,sBAAsB;IAC9C,IAAI,YAAY,mCAAa;IAC7B,IAAI,SAAS,0CAAuB,WAAW;kBAAC;IAAQ,GAAG;IAC3D,OAAO,WAAW,GAAG;IACrB,IAAI,WAAW,OAAO,QAAQ;IAE9B,qFAAqF;IACrF,IAAI,YAAY,CAAC,UAAU;QACzB,YAAY,mCAAa;QACzB,SAAS,0CAAuB,WAAW;YAAC,UAAU;QAAK,GAAG;QAC9D,OAAO,WAAW,GAAG;QACrB,WAAW,OAAO,QAAQ;IAC5B;IAEA,mCAAa;AACf;AAEA,SAAS,mCAAa,QAA8B,EAAE,SAAmB;IACvE,MAAM,eAAe,CAAA,GAAA,YAAI,EAAE,MAAM,CAAC;IAClC,CAAA,GAAA,gBAAQ,EAAE;QACR,IAAI,aAAa,OAAO,EAAE;YACxB,oCAAc;YACd,MAAM,gBAAgB,CAAA,GAAA,uBAAe,EAAE,SAAS,OAAO,GAAG,SAAS,OAAO,CAAC,EAAE,GAAG;YAChF,IAAI,CAAC,uCAAiB,cAAc,aAAa,EAAE,kCAAY,OAAO,KAAK,SAAS,OAAO,EACzF,wCAAkB,SAAS,OAAO;QAEtC;QACA,aAAa,OAAO,GAAG;IACzB,GAAG;QAAC;KAAS;AACf;AAEA,SAAS,4CAAsB,QAA8B,EAAE,OAAiB,EAAE,OAAiB;IACjG,uEAAuE;IACvE,iFAAiF;IACjF,CAAA,GAAA,sBAAc,EAAE;QACd,IAAI,WAAW,SACb;QAGF,IAAI,QAAQ,SAAS,OAAO;QAC5B,MAAM,gBAAgB,CAAA,GAAA,uBAAe,EAAE,QAAQ,KAAK,CAAC,EAAE,GAAG;QAE1D,IAAI,UAAU,CAAC;YACb,IAAI,SAAS,EAAE,MAAM;YACrB,IAAI,uCAAiB,QAAQ,SAAS,OAAO,GAC3C,oCAAc;iBACT,IAAI,CAAC,0CAAoB,SAC9B,oCAAc;QAElB;QAEA,cAAc,gBAAgB,CAAC,WAAW,SAAS;QACnD,kBAAA,4BAAA,MAAO,OAAO,CAAC,CAAA,UAAW,QAAQ,gBAAgB,CAAC,WAAW,SAAS;QACvE,OAAO;YACL,cAAc,mBAAmB,CAAC,WAAW,SAAS;YACtD,kBAAA,4BAAA,MAAO,OAAO,CAAC,CAAA,UAAW,QAAQ,mBAAmB,CAAC,WAAW,SAAS;QAC5E;IACF,GAAG;QAAC;QAAU;QAAS;KAAQ;AACjC;AAEA,SAAS,yCAAmB,QAAkB;IAC5C,IAAI,QAAQ,0CAAe,WAAW,CAAC;IACvC,MAAO,SAAS,MAAM,QAAQ,KAAK,SAAU;QAC3C,IAAI,MAAM,aAAa,EACrB,OAAO;QAGT,QAAQ,MAAM,MAAM;IACtB;IAEA,OAAO,CAAA,kBAAA,4BAAA,MAAO,QAAQ,MAAK;AAC7B;AAEA,SAAS,sCAAgB,QAA8B,EAAE,YAAsB,EAAE,OAAiB;IAChG,kIAAkI;IAClI,iDAAiD;IACjD,MAAM,mBAAmB,CAAA,GAAA,aAAK,EAAE,OAAO,aAAa,cAAc,CAAA,GAAA,uBAAe,EAAE,SAAS,OAAO,GAAG,SAAS,OAAO,CAAC,EAAE,GAAG,WAAW,aAAa,GAAuB;IAE3K,4IAA4I;IAC5I,yGAAyG;IACzG,CAAA,GAAA,sBAAc,EAAE;QACd,IAAI,QAAQ,SAAS,OAAO;QAC5B,MAAM,gBAAgB,CAAA,GAAA,uBAAe,EAAE,QAAQ,KAAK,CAAC,EAAE,GAAG;QAC1D,IAAI,CAAC,gBAAgB,SACnB;QAGF,IAAI,UAAU;YACZ,mGAAmG;YACnG,gEAAgE;YAChE,IAAI,AAAC,CAAA,CAAC,qCAAe,sCAAgB,mCAAa,SAAQ,KAC1D,uCAAiB,cAAc,aAAa,EAAE,SAAS,OAAO,GAE5D,oCAAc;QAElB;QAEA,cAAc,gBAAgB,CAAC,WAAW,SAAS;QACnD,kBAAA,4BAAA,MAAO,OAAO,CAAC,CAAA,UAAW,QAAQ,gBAAgB,CAAC,WAAW,SAAS;QACvE,OAAO;YACL,cAAc,mBAAmB,CAAC,WAAW,SAAS;YACtD,kBAAA,4BAAA,MAAO,OAAO,CAAC,CAAA,UAAW,QAAQ,mBAAmB,CAAC,WAAW,SAAS;QAC5E;IACF,uDAAuD;IACvD,GAAG;QAAC;QAAU;KAAQ;IAEtB,CAAA,GAAA,sBAAc,EAAE;QACd,MAAM,gBAAgB,CAAA,GAAA,uBAAe,EAAE,SAAS,OAAO,GAAG,SAAS,OAAO,CAAC,EAAE,GAAG;QAEhF,IAAI,CAAC,cACH;QAGF,+EAA+E;QAC/E,+EAA+E;QAC/E,8EAA8E;QAC9E,8BAA8B;QAC9B,IAAI,YAAY,CAAC;YACf,IAAI,EAAE,GAAG,KAAK,SAAS,EAAE,MAAM,IAAI,EAAE,OAAO,IAAI,EAAE,OAAO,IAAI,CAAC,yCAAmB,aAAa,EAAE,WAAW,EACzG;YAGF,IAAI,iBAAiB,cAAc,aAAa;YAChD,IAAI,CAAC,uCAAiB,gBAAgB,SAAS,OAAO,GACpD;YAEF,IAAI,WAAW,0CAAe,WAAW,CAAC;YAC1C,IAAI,CAAC,UACH;YAEF,IAAI,gBAAgB,SAAS,aAAa;YAE1C,8DAA8D;YAC9D,IAAI,SAAS,0CAAuB,cAAc,IAAI,EAAE;gBAAC,UAAU;YAAI;YAEvE,qEAAqE;YACrE,OAAO,WAAW,GAAG;YACrB,IAAI,cAAe,EAAE,QAAQ,GAAG,OAAO,YAAY,KAAK,OAAO,QAAQ;YAEvE,IAAI,CAAC,iBAAiB,CAAC,cAAc,IAAI,CAAC,QAAQ,CAAC,kBAAkB,kBAAkB,cAAc,IAAI,EAAE;gBACzG,gBAAgB;gBAChB,SAAS,aAAa,GAAG;YAC3B;YAEA,qFAAqF;YACrF,qDAAqD;YACrD,IAAI,AAAC,CAAA,CAAC,eAAe,CAAC,uCAAiB,aAAa,SAAS,OAAO,CAAA,KAAM,eAAe;gBACvF,OAAO,WAAW,GAAG;gBAErB,kGAAkG;gBAClG,GACE,cAAe,EAAE,QAAQ,GAAG,OAAO,YAAY,KAAK,OAAO,QAAQ;uBAC5D,uCAAiB,aAAa,SAAS,OAAO,GAAG;gBAE1D,EAAE,cAAc;gBAChB,EAAE,eAAe;gBACjB,IAAI,aACF,mCAAa,aAAa;qBAEzB,8HAA8H;gBAC9H,+BAA+B;gBAC/B,0IAA0I;gBAC3I,IAAI,CAAC,0CAAoB,gBACvB,eAAe,IAAI;qBAEnB,mCAAa,eAAe;YAGlC;QACF;QAEA,IAAI,CAAC,SACH,cAAc,gBAAgB,CAAC,WAAW,WAAW;QAGvD,OAAO;YACL,IAAI,CAAC,SACH,cAAc,mBAAmB,CAAC,WAAW,WAAW;QAE5D;IACF,GAAG;QAAC;QAAU;QAAc;KAAQ;IAEpC,+GAA+G;IAC/G,CAAA,GAAA,sBAAc,EAAE;QACd,MAAM,gBAAgB,CAAA,GAAA,uBAAe,EAAE,SAAS,OAAO,GAAG,SAAS,OAAO,CAAC,EAAE,GAAG;QAEhF,IAAI,CAAC,cACH;QAGF,IAAI,WAAW,0CAAe,WAAW,CAAC;QAC1C,IAAI,CAAC,UACH;YAEuB;QAAzB,SAAS,aAAa,GAAG,CAAA,4BAAA,iBAAiB,OAAO,cAAxB,uCAAA,4BAA4B;QACrD,OAAO;YACL,IAAI,WAAW,0CAAe,WAAW,CAAC;YAC1C,IAAI,CAAC,UACH;YAEF,IAAI,gBAAgB,SAAS,aAAa;YAE1C,wGAAwG;YACxG,IACE,gBACG,iBAED,uDAAuD;YACvD,CAAA,uCAAiB,cAAc,aAAa,EAAE,SAAS,OAAO,KAC1D,cAAc,aAAa,KAAK,cAAc,IAAI,IAAI,yCAAmB,SAAS,GAExF;gBACA,6GAA6G;gBAC7G,IAAI,aAAa,0CAAe,KAAK;gBACrC,sBAAsB;oBACpB,0HAA0H;oBAC1H,IAAI,cAAc,aAAa,KAAK,cAAc,IAAI,EAAE;wBACtD,oFAAoF;wBACpF,IAAI,WAAW,WAAW,WAAW,CAAC;wBACtC,MAAO,SAAU;4BACf,IAAI,SAAS,aAAa,IAAI,SAAS,aAAa,CAAC,WAAW,EAAE;gCAChE,mCAAa,SAAS,aAAa;gCACnC;4BACF;4BACA,WAAW,SAAS,MAAM;wBAC5B;wBAEA,wEAAwE;wBACxE,4CAA4C;wBAC5C,WAAW,WAAW,WAAW,CAAC;wBAClC,MAAO,SAAU;4BACf,IAAI,SAAS,QAAQ,IAAI,SAAS,QAAQ,CAAC,OAAO,IAAI,0CAAe,WAAW,CAAC,SAAS,QAAQ,GAAG;gCACnG,wCAAkB,SAAS,QAAQ,CAAC,OAAO,EAAE;gCAC7C;4BACF;4BACA,WAAW,SAAS,MAAM;wBAC5B;oBACF;gBACF;YACF;QACF;IACF,GAAG;QAAC;QAAU;KAAa;AAC7B;AAMO,SAAS,0CAAuB,IAAa,EAAE,IAA0B,EAAE,KAAiB;IACjG,IAAI,WAAW,CAAA,iBAAA,2BAAA,KAAM,QAAQ,IAAG,kDAA4B;IAC5D,IAAI,SAAS,CAAA,GAAA,uBAAe,EAAE,MAAM,gBAAgB,CAClD,MACA,WAAW,YAAY,EACvB;QACE,YAAW,IAAI;gBAET;YADJ,uCAAuC;YACvC,IAAI,iBAAA,4BAAA,aAAA,KAAM,IAAI,cAAV,iCAAA,WAAY,QAAQ,CAAC,OACvB,OAAO,WAAW,aAAa;YAGjC,IAAI,AAAC,KAAiB,OAAO,CAAC,aACzB,CAAA,GAAA,yCAAe,EAAE,SAChB,CAAA,CAAC,SAAS,uCAAiB,MAAiB,MAAK,KACjD,CAAA,EAAC,iBAAA,2BAAA,KAAM,MAAM,KAAI,KAAK,MAAM,CAAC,KAAe,GAEhD,OAAO,WAAW,aAAa;YAGjC,OAAO,WAAW,WAAW;QAC/B;IACF;IAGF,IAAI,iBAAA,2BAAA,KAAM,IAAI,EACZ,OAAO,WAAW,GAAG,KAAK,IAAI;IAGhC,OAAO;AACT;AAKO,SAAS,yCAAmB,GAAuB,EAAE,iBAAsC,CAAC,CAAC;IAClG,OAAO;QACL,WAAU,OAA4B,CAAC,CAAC;YACtC,IAAI,OAAO,IAAI,OAAO;YACtB,IAAI,CAAC,MACH,OAAO;YAET,IAAI,QAAC,IAAI,YAAE,WAAW,eAAe,QAAQ,QAAE,OAAO,eAAe,IAAI,UAAE,SAAS,eAAe,MAAM,EAAC,GAAG;YAC7G,IAAI,OAAO,QAAQ,CAAA,GAAA,uBAAe,EAAE,MAAM,aAAa;YACvD,IAAI,SAAS,0CAAuB,MAAM;0BAAC;wBAAU;YAAM;YAC3D,IAAI,KAAK,QAAQ,CAAC,OAChB,OAAO,WAAW,GAAG;YAEvB,IAAI,WAAW,OAAO,QAAQ;YAC9B,IAAI,CAAC,YAAY,MAAM;gBACrB,OAAO,WAAW,GAAG;gBACrB,WAAW,OAAO,QAAQ;YAC5B;YACA,IAAI,UACF,mCAAa,UAAU;YAEzB,OAAO;QACT;QACA,eAAc,OAA4B,cAAc;YACtD,IAAI,OAAO,IAAI,OAAO;YACtB,IAAI,CAAC,MACH,OAAO;YAET,IAAI,QAAC,IAAI,YAAE,WAAW,eAAe,QAAQ,QAAE,OAAO,eAAe,IAAI,UAAE,SAAS,eAAe,MAAM,EAAC,GAAG;YAC7G,IAAI,OAAO,QAAQ,CAAA,GAAA,uBAAe,EAAE,MAAM,aAAa;YACvD,IAAI,SAAS,0CAAuB,MAAM;0BAAC;wBAAU;YAAM;YAC3D,IAAI,KAAK,QAAQ,CAAC,OAChB,OAAO,WAAW,GAAG;iBAChB;gBACL,IAAI,OAAO,2BAAK;gBAChB,IAAI,MACF,mCAAa,MAAM;gBAErB,OAAO,iBAAA,kBAAA,OAAQ;YACjB;YACA,IAAI,eAAe,OAAO,YAAY;YACtC,IAAI,CAAC,gBAAgB,MAAM;gBACzB,OAAO,WAAW,GAAG;gBACrB,IAAI,WAAW,2BAAK;gBACpB,IAAI,CAAC,UACH,gBAAgB;gBAChB,OAAO;gBAET,eAAe;YACjB;YACA,IAAI,cACF,mCAAa,cAAc;YAE7B,OAAO,yBAAA,0BAAA,eAAgB;QACzB;QACA,YAAW,OAAO,cAAc;YAC9B,IAAI,OAAO,IAAI,OAAO;YACtB,IAAI,CAAC,MACH,OAAO;YAET,IAAI,YAAC,WAAW,eAAe,QAAQ,UAAE,SAAS,eAAe,MAAM,EAAC,GAAG;YAC3E,IAAI,SAAS,0CAAuB,MAAM;0BAAC;wBAAU;YAAM;YAC3D,IAAI,WAAW,OAAO,QAAQ;YAC9B,IAAI,UACF,mCAAa,UAAU;YAEzB,OAAO;QACT;QACA,WAAU,OAAO,cAAc;YAC7B,IAAI,OAAO,IAAI,OAAO;YACtB,IAAI,CAAC,MACH,OAAO;YAET,IAAI,YAAC,WAAW,eAAe,QAAQ,UAAE,SAAS,eAAe,MAAM,EAAC,GAAG;YAC3E,IAAI,SAAS,0CAAuB,MAAM;0BAAC;wBAAU;YAAM;YAC3D,IAAI,OAAO,2BAAK;YAChB,IAAI,MACF,mCAAa,MAAM;YAErB,OAAO,iBAAA,kBAAA,OAAQ;QACjB;IACF;AACF;AAEA,SAAS,2BAAK,MAAkB;IAC9B,IAAI,OAAqC;IACzC,IAAI;IACJ,GAAG;QACD,OAAO,OAAO,SAAS;QACvB,IAAI,MACF,OAAO;IAEX,QAAS,MAAM;IACf,OAAO;AACT;AAGA,MAAM;IASJ,IAAI,OAAO;QACT,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI;IAC1B;IAEA,YAAY,IAAc,EAAE;QAC1B,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;IAC1B;IAEA,YAAY,QAAkB,EAAE,MAAgB,EAAE,aAAgC,EAAE;QAClF,IAAI,aAAa,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,mBAAA,oBAAA,SAAU;QAC5C,IAAI,CAAC,YACH;QAEF,IAAI,OAAO,IAAI,+BAAS;sBAAC;QAAQ;QACjC,WAAW,QAAQ,CAAC;QACpB,KAAK,MAAM,GAAG;QACd,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU;QAC3B,IAAI,eACF,KAAK,aAAa,GAAG;IAEzB;IAEA,QAAQ,IAAc,EAAE;QACtB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,QAAQ,EAAE;IAClC;IAEA,eAAe,QAAkB,EAAE;QACjC,wBAAwB;QACxB,IAAI,aAAa,MACf;QAEF,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;QAC5B,IAAI,CAAC,MACH;QAEF,IAAI,aAAa,KAAK,MAAM;QAC5B,+HAA+H;QAC/H,8FAA8F;QAC9F,KAAK,IAAI,WAAW,IAAI,CAAC,QAAQ,GAC/B,IACE,YAAY,QACZ,KAAK,aAAa,IAClB,QAAQ,aAAa,IACrB,KAAK,QAAQ,IACb,KAAK,QAAQ,CAAC,OAAO,IACrB,uCAAiB,QAAQ,aAAa,EAAE,KAAK,QAAQ,CAAC,OAAO,GAE7D,QAAQ,aAAa,GAAG,KAAK,aAAa;QAG9C,IAAI,WAAW,KAAK,QAAQ;QAC5B,IAAI,YAAY;YACd,WAAW,WAAW,CAAC;YACvB,IAAI,SAAS,IAAI,GAAG,GAClB,SAAS,OAAO,CAAC,CAAA,QAAS,cAAc,WAAW,QAAQ,CAAC;QAEhE;QAEA,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,QAAQ;IACnC;IAEA,wBAAwB;IACxB,CAAC,SAAS,OAAiB,IAAI,CAAC,IAAI,EAAuB;QACzD,IAAI,KAAK,QAAQ,IAAI,MACnB,MAAM;QAER,IAAI,KAAK,QAAQ,CAAC,IAAI,GAAG,GACvB,KAAK,IAAI,SAAS,KAAK,QAAQ,CAC7B,OAAO,IAAI,CAAC,QAAQ,CAAC;IAG3B;IAEA,QAAc;YAGyB;QAFrC,IAAI,UAAU,IAAI;YAEmB;QADrC,KAAK,IAAI,QAAQ,IAAI,CAAC,QAAQ,GAC5B,QAAQ,WAAW,CAAC,KAAK,QAAQ,EAAE,CAAA,yBAAA,eAAA,KAAK,MAAM,cAAX,mCAAA,aAAa,QAAQ,cAArB,mCAAA,wBAAyB,MAAM,KAAK,aAAa;QAEtF,OAAO;IACT;IApFA,aAAc;aAFN,UAAU,IAAI;QAGpB,IAAI,CAAC,IAAI,GAAG,IAAI,+BAAS;YAAC,UAAU;QAAI;QACxC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,IAAI,CAAC,IAAI;IAClC;AAkFF;AAEA,MAAM;IAUJ,SAAS,IAAc,EAAE;QACvB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC;QAClB,KAAK,MAAM,GAAG,IAAI;IACpB;IACA,YAAY,IAAc,EAAE;QAC1B,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC;QACrB,KAAK,MAAM,GAAG;IAChB;IAVA,YAAY,KAA2B,CAAE;aAHlC,WAA0B,IAAI;aAC9B,UAAU;QAGf,IAAI,CAAC,QAAQ,GAAG,MAAM,QAAQ;IAChC;AASF;AAEO,IAAI,4CAAiB,IAAI","sources":["packages/@react-aria/focus/src/FocusScope.tsx"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusSafely} from './focusSafely';\nimport {getOwnerDocument, useLayoutEffect} from '@react-aria/utils';\nimport {isElementVisible} from './isElementVisible';\nimport React, {ReactNode, RefObject, useContext, useEffect, useMemo, useRef} from 'react';\n\nexport interface FocusScopeProps {\n  /** The contents of the focus scope. */\n  children: ReactNode,\n\n  /**\n   * Whether to contain focus inside the scope, so users cannot\n   * move focus outside, for example in a modal dialog.\n   */\n  contain?: boolean,\n\n  /**\n   * Whether to restore focus back to the element that was focused\n   * when the focus scope mounted, after the focus scope unmounts.\n   */\n  restoreFocus?: boolean,\n\n  /** Whether to auto focus the first focusable element in the focus scope on mount. */\n  autoFocus?: boolean\n}\n\nexport interface FocusManagerOptions {\n  /** The element to start searching from. The currently focused element by default. */\n  from?: Element,\n  /** Whether to only include tabbable elements, or all focusable elements. */\n  tabbable?: boolean,\n  /** Whether focus should wrap around when it reaches the end of the scope. */\n  wrap?: boolean,\n  /** A callback that determines whether the given element is focused. */\n  accept?: (node: Element) => boolean\n}\n\nexport interface FocusManager {\n  /** Moves focus to the next focusable or tabbable element in the focus scope. */\n  focusNext(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the previous focusable or tabbable element in the focus scope. */\n  focusPrevious(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the first focusable or tabbable element in the focus scope. */\n  focusFirst(opts?: FocusManagerOptions): FocusableElement | null,\n    /** Moves focus to the last focusable or tabbable element in the focus scope. */\n  focusLast(opts?: FocusManagerOptions): FocusableElement | null\n}\n\ntype ScopeRef = RefObject<Element[]> | null;\ninterface IFocusContext {\n  focusManager: FocusManager,\n  parentNode: TreeNode | null\n}\n\nconst FocusContext = React.createContext<IFocusContext | null>(null);\n\nlet activeScope: ScopeRef = null;\n\n// This is a hacky DOM-based implementation of a FocusScope until this RFC lands in React:\n// https://github.com/reactjs/rfcs/pull/109\n\n/**\n * A FocusScope manages focus for its descendants. It supports containing focus inside\n * the scope, restoring focus to the previously focused element on unmount, and auto\n * focusing children on mount. It also acts as a container for a programmatic focus\n * management interface that can be used to move focus forward and back in response\n * to user events.\n */\nexport function FocusScope(props: FocusScopeProps) {\n  let {children, contain, restoreFocus, autoFocus} = props;\n  let startRef = useRef<HTMLSpanElement>(null);\n  let endRef = useRef<HTMLSpanElement>(null);\n  let scopeRef = useRef<Element[]>([]);\n  let {parentNode} = useContext(FocusContext) || {};\n\n  // Create a tree node here so we can add children to it even before it is added to the tree.\n  let node = useMemo(() => new TreeNode({scopeRef}), [scopeRef]);\n\n  useLayoutEffect(() => {\n    // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),\n    // use the active scope as the parent instead of the parent from context. Layout effects run bottom\n    // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope\n    // that is being added should get the activeScope as its parent.\n    let parent = parentNode || focusScopeTree.root;\n    if (focusScopeTree.getTreeNode(parent.scopeRef) && activeScope && !isAncestorScope(activeScope, parent.scopeRef)) {\n      let activeNode = focusScopeTree.getTreeNode(activeScope);\n      if (activeNode) {\n        parent = activeNode;\n      }\n    }\n\n    // Add the node to the parent, and to the tree.\n    parent.addChild(node);\n    focusScopeTree.addNode(node);\n  }, [node, parentNode]);\n\n  useLayoutEffect(() => {\n    let node = focusScopeTree.getTreeNode(scopeRef);\n    if (node) {\n      node.contain = !!contain;\n    }\n  }, [contain]);\n\n  useLayoutEffect(() => {\n    // Find all rendered nodes between the sentinels and add them to the scope.\n    let node = startRef.current?.nextSibling!;\n    let nodes: Element[] = [];\n    while (node && node !== endRef.current) {\n      nodes.push(node as Element);\n      node = node.nextSibling as Element;\n    }\n\n    scopeRef.current = nodes;\n  }, [children]);\n\n  useActiveScopeTracker(scopeRef, restoreFocus, contain);\n  useFocusContainment(scopeRef, contain);\n  useRestoreFocus(scopeRef, restoreFocus, contain);\n  useAutoFocus(scopeRef, autoFocus);\n\n  // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.\n  // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.\n  useEffect(() => {\n    const activeElement = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement;\n    let scope: TreeNode | null = null;\n\n    if (isElementInScope(activeElement, scopeRef.current)) {\n      // We need to traverse the focusScope tree and find the bottom most scope that\n      // contains the active element and set that as the activeScope.\n      for (let node of focusScopeTree.traverse()) {\n        if (node.scopeRef && isElementInScope(activeElement, node.scopeRef.current)) {\n          scope = node;\n        }\n      }\n\n      if (scope === focusScopeTree.getTreeNode(scopeRef)) {\n        activeScope = scope.scopeRef;\n      }\n    }\n  }, [scopeRef]);\n\n  // This layout effect cleanup is so that the tree node is removed synchronously with react before the RAF\n  // in useRestoreFocus cleanup runs.\n  useLayoutEffect(() => {\n    return () => {\n      // Scope may have been re-parented.\n      let parentScope = focusScopeTree.getTreeNode(scopeRef)?.parent?.scopeRef ?? null;\n\n      if (\n        (scopeRef === activeScope || isAncestorScope(scopeRef, activeScope)) &&\n        (!parentScope || focusScopeTree.getTreeNode(parentScope))\n      ) {\n        activeScope = parentScope;\n      }\n      focusScopeTree.removeTreeNode(scopeRef);\n    };\n  }, [scopeRef]);\n\n  let focusManager = useMemo(() => createFocusManagerForScope(scopeRef), []);\n  let value = useMemo(() => ({\n    focusManager,\n    parentNode: node\n  }), [node, focusManager]);\n\n  return (\n    <FocusContext.Provider value={value}>\n      <span data-focus-scope-start hidden ref={startRef} />\n      {children}\n      <span data-focus-scope-end hidden ref={endRef} />\n    </FocusContext.Provider>\n  );\n}\n\n/**\n * Returns a FocusManager interface for the parent FocusScope.\n * A FocusManager can be used to programmatically move focus within\n * a FocusScope, e.g. in response to user events like keyboard navigation.\n */\nexport function useFocusManager(): FocusManager | undefined {\n  return useContext(FocusContext)?.focusManager;\n}\n\nfunction createFocusManagerForScope(scopeRef: React.RefObject<Element[]>): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getOwnerDocument(scope[0]).activeElement!;\n      let sentinel = scope[0].previousElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getOwnerDocument(scope[0]).activeElement!;\n      let sentinel = scope[scope.length - 1].nextElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = sentinel;\n        previousNode = walker.previousNode() as FocusableElement;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    },\n    focusFirst(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[0].previousElementSibling!;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[scope.length - 1].nextElementSibling!;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    }\n  };\n}\n\nconst focusableElements = [\n  'input:not([disabled]):not([type=hidden])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n  'button:not([disabled])',\n  'a[href]',\n  'area[href]',\n  'summary',\n  'iframe',\n  'object',\n  'embed',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]'\n];\n\nconst FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';\n\nfocusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\n\nexport function isFocusable(element: HTMLElement) {\n  return element.matches(FOCUSABLE_ELEMENT_SELECTOR);\n}\n\nfunction getScopeRoot(scope: Element[]) {\n  return scope[0].parentElement!;\n}\n\nfunction shouldContainFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.contain) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return true;\n}\n\nfunction useFocusContainment(scopeRef: RefObject<Element[]>, contain?: boolean) {\n  let focusedNode = useRef<FocusableElement>();\n\n  let raf = useRef<ReturnType<typeof requestAnimationFrame>>();\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    if (!contain) {\n      // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n        raf.current = undefined;\n      }\n      return;\n    }\n\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n\n    // Handle the Tab key to contain focus within the scope\n    let onKeyDown = (e) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef) || e.isComposing) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement;\n      let scope = scopeRef.current;\n      if (!scope || !isElementInScope(focusedElement, scope)) {\n        return;\n      }\n\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable: true}, scope);\n      if (!focusedElement) {\n        return;\n      }\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      if (!nextElement) {\n        walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling! : scope[0].previousElementSibling!;\n        nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      }\n\n      e.preventDefault();\n      if (nextElement) {\n        focusElement(nextElement, true);\n      }\n    };\n\n    let onFocus = (e) => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) && isElementInScope(e.target, scopeRef.current)) {\n        activeScope = scopeRef;\n        focusedNode.current = e.target;\n      } else if (shouldContainFocus(scopeRef) && !isElementInChildScope(e.target, scopeRef)) {\n        // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n        // restore focus to the previously focused node or the first tabbable element in the active scope.\n        if (focusedNode.current) {\n          focusedNode.current.focus();\n        } else if (activeScope && activeScope.current) {\n          focusFirstInScope(activeScope.current);\n        }\n      } else if (shouldContainFocus(scopeRef)) {\n        focusedNode.current = e.target;\n      }\n    };\n\n    let onBlur = (e) => {\n      // Firefox doesn't shift focus back to the Dialog properly without this\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n      raf.current = requestAnimationFrame(() => {\n        // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n        if (ownerDocument.activeElement && shouldContainFocus(scopeRef) && !isElementInChildScope(ownerDocument.activeElement, scopeRef)) {\n          activeScope = scopeRef;\n          if (ownerDocument.body.contains(e.target)) {\n            focusedNode.current = e.target;\n            focusedNode.current?.focus();\n          } else if (activeScope.current) {\n            focusFirstInScope(activeScope.current);\n          }\n        }\n      });\n    };\n\n    ownerDocument.addEventListener('keydown', onKeyDown, false);\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    scope?.forEach(element => element.addEventListener('focusout', onBlur, false));\n    return () => {\n      ownerDocument.removeEventListener('keydown', onKeyDown, false);\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n      scope?.forEach(element => element.removeEventListener('focusout', onBlur, false));\n    };\n  }, [scopeRef, contain]);\n\n  // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur\n  // eslint-disable-next-line arrow-body-style\n  useLayoutEffect(() => {\n    return () => {\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n    };\n  }, [raf]);\n}\n\nfunction isElementInAnyScope(element: Element) {\n  return isElementInChildScope(element);\n}\n\nfunction isElementInScope(element?: Element | null, scope?: Element[] | null) {\n  if (!element) {\n    return false;\n  }\n  if (!scope) {\n    return false;\n  }\n  return scope.some(node => node.contains(element));\n}\n\nfunction isElementInChildScope(element: Element, scope: ScopeRef = null) {\n  // If the element is within a top layer element (e.g. toasts), always allow moving focus there.\n  if (element instanceof Element && element.closest('[data-react-aria-top-layer]')) {\n    return true;\n  }\n\n  // node.contains in isElementInScope covers child scopes that are also DOM children,\n  // but does not cover child scopes in portals.\n  for (let {scopeRef: s} of focusScopeTree.traverse(focusScopeTree.getTreeNode(scope))) {\n    if (s && isElementInScope(element, s.current)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/** @private */\nexport function isElementInChildOfActiveScope(element: Element) {\n  return isElementInChildScope(element, activeScope);\n}\n\nfunction isAncestorScope(ancestor: ScopeRef, scope: ScopeRef) {\n  let parent = focusScopeTree.getTreeNode(scope)?.parent;\n  while (parent) {\n    if (parent.scopeRef === ancestor) {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction focusElement(element: FocusableElement | null, scroll = false) {\n  if (element != null && !scroll) {\n    try {\n      focusSafely(element);\n    } catch (err) {\n      // ignore\n    }\n  } else if (element != null) {\n    try {\n      element.focus();\n    } catch (err) {\n      // ignore\n    }\n  }\n}\n\nfunction focusFirstInScope(scope: Element[], tabbable:boolean = true) {\n  let sentinel = scope[0].previousElementSibling!;\n  let scopeRoot = getScopeRoot(scope);\n  let walker = getFocusableTreeWalker(scopeRoot, {tabbable}, scope);\n  walker.currentNode = sentinel;\n  let nextNode = walker.nextNode();\n\n  // If the scope does not contain a tabbable element, use the first focusable element.\n  if (tabbable && !nextNode) {\n    scopeRoot = getScopeRoot(scope);\n    walker = getFocusableTreeWalker(scopeRoot, {tabbable: false}, scope);\n    walker.currentNode = sentinel;\n    nextNode = walker.nextNode();\n  }\n\n  focusElement(nextNode as FocusableElement);\n}\n\nfunction useAutoFocus(scopeRef: RefObject<Element[]>, autoFocus?: boolean) {\n  const autoFocusRef = React.useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      activeScope = scopeRef;\n      const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n      if (!isElementInScope(ownerDocument.activeElement, activeScope.current) && scopeRef.current) {\n        focusFirstInScope(scopeRef.current);\n      }\n    }\n    autoFocusRef.current = false;\n  }, [scopeRef]);\n}\n\nfunction useActiveScopeTracker(scopeRef: RefObject<Element[]>, restore?: boolean, contain?: boolean) {\n  // tracks the active scope, in case restore and contain are both false.\n  // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n  useLayoutEffect(() => {\n    if (restore || contain) {\n      return;\n    }\n\n    let scope = scopeRef.current;\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n\n    let onFocus = (e) => {\n      let target = e.target as Element;\n      if (isElementInScope(target, scopeRef.current)) {\n        activeScope = scopeRef;\n      } else if (!isElementInAnyScope(target)) {\n        activeScope = null;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n  }, [scopeRef, restore, contain]);\n}\n\nfunction shouldRestoreFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.nodeToRestore) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return scope?.scopeRef === scopeRef;\n}\n\nfunction useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean, contain?: boolean) {\n  // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n  // eslint-disable-next-line no-restricted-globals\n  const nodeToRestoreRef = useRef(typeof document !== 'undefined' ? getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement as FocusableElement : null);\n\n  // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n  // restoring-non-containing scopes should only care if they become active so they can perform the restore\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);\n    if (!restoreFocus || contain) {\n      return;\n    }\n\n    let onFocus = () => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) &&\n      isElementInScope(ownerDocument.activeElement, scopeRef.current)\n      ) {\n        activeScope = scopeRef;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [scopeRef, contain]);\n\n  useLayoutEffect(() => {\n    const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    // Handle the Tab key so that tabbing out of the scope goes to the next element\n    // after the node that had focus when the scope mounted. This is important when\n    // using portals for overlays, so that focus goes to the expected element when\n    // tabbing out of the overlay.\n    let onKeyDown = (e: KeyboardEvent) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef) || e.isComposing) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement as FocusableElement;\n      if (!isElementInScope(focusedElement, scopeRef.current)) {\n        return;\n      }\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      // Create a DOM tree walker that matches all tabbable elements\n      let walker = getFocusableTreeWalker(ownerDocument.body, {tabbable: true});\n\n      // Find the next tabbable element after the currently focused element\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n\n      if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {\n        nodeToRestore = undefined;\n        treeNode.nodeToRestore = undefined;\n      }\n\n      // If there is no next element, or it is outside the current scope, move focus to the\n      // next element after the node to restore to instead.\n      if ((!nextElement || !isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n        walker.currentNode = nodeToRestore;\n\n        // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n        do {\n          nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n        } while (isElementInScope(nextElement, scopeRef.current));\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (nextElement) {\n          focusElement(nextElement, true);\n        } else {\n           // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)\n           // then move focus to the body.\n           // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n          if (!isElementInAnyScope(nodeToRestore)) {\n            focusedElement.blur();\n          } else {\n            focusElement(nodeToRestore, true);\n          }\n        }\n      }\n    };\n\n    if (!contain) {\n      ownerDocument.addEventListener('keydown', onKeyDown, true);\n    }\n\n    return () => {\n      if (!contain) {\n        ownerDocument.removeEventListener('keydown', onKeyDown, true);\n      }\n    };\n  }, [scopeRef, restoreFocus, contain]);\n\n  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n  useLayoutEffect(() => {\n    const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    let treeNode = focusScopeTree.getTreeNode(scopeRef);\n    if (!treeNode) {\n      return;\n    }\n    treeNode.nodeToRestore = nodeToRestoreRef.current ?? undefined;\n    return () => {\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n      if (\n        restoreFocus\n        && nodeToRestore\n        && (\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          isElementInScope(ownerDocument.activeElement, scopeRef.current)\n          || (ownerDocument.activeElement === ownerDocument.body && shouldRestoreFocus(scopeRef))\n        )\n      ) {\n        // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n        let clonedTree = focusScopeTree.clone();\n        requestAnimationFrame(() => {\n          // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n          if (ownerDocument.activeElement === ownerDocument.body) {\n            // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n            let treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {\n                focusElement(treeNode.nodeToRestore);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n\n            // If no nodeToRestore was found, focus the first element in the nearest\n            // ancestor scope that is still in the tree.\n            treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.scopeRef && treeNode.scopeRef.current && focusScopeTree.getTreeNode(treeNode.scopeRef)) {\n                focusFirstInScope(treeNode.scopeRef.current, true);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n          }\n        });\n      }\n    };\n  }, [scopeRef, restoreFocus]);\n}\n\n/**\n * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}\n * that matches all focusable/tabbable elements.\n */\nexport function getFocusableTreeWalker(root: Element, opts?: FocusManagerOptions, scope?: Element[]) {\n  let selector = opts?.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;\n  let walker = getOwnerDocument(root).createTreeWalker(\n    root,\n    NodeFilter.SHOW_ELEMENT,\n    {\n      acceptNode(node) {\n        // Skip nodes inside the starting node.\n        if (opts?.from?.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if ((node as Element).matches(selector)\n          && isElementVisible(node as Element)\n          && (!scope || isElementInScope(node as Element, scope))\n          && (!opts?.accept || opts.accept(node as Element))\n        ) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      }\n    }\n  );\n\n  if (opts?.from) {\n    walker.currentNode = opts.from;\n  }\n\n  return walker;\n}\n\n/**\n * Creates a FocusManager object that can be used to move focus within an element.\n */\nexport function createFocusManager(ref: RefObject<Element>, defaultOptions: FocusManagerOptions = {}): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || getOwnerDocument(root).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      }\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = root;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || getOwnerDocument(root).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      } else {\n        let next = last(walker);\n        if (next) {\n          focusElement(next, true);\n        }\n        return next ?? null;\n      }\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = root;\n        let lastNode = last(walker);\n        if (!lastNode) {\n          // couldn't wrap\n          return null;\n        }\n        previousNode = lastNode;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode ?? null;\n    },\n    focusFirst(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let next = last(walker);\n      if (next) {\n        focusElement(next, true);\n      }\n      return next ?? null;\n    }\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement | undefined = undefined;\n  let last: FocusableElement;\n  do {\n    last = walker.lastChild() as FocusableElement;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n\n\nclass Tree {\n  root: TreeNode;\n  private fastMap = new Map<ScopeRef, TreeNode>();\n\n  constructor() {\n    this.root = new TreeNode({scopeRef: null});\n    this.fastMap.set(null, this.root);\n  }\n\n  get size() {\n    return this.fastMap.size;\n  }\n\n  getTreeNode(data: ScopeRef) {\n    return this.fastMap.get(data);\n  }\n\n  addTreeNode(scopeRef: ScopeRef, parent: ScopeRef, nodeToRestore?: FocusableElement) {\n    let parentNode = this.fastMap.get(parent ?? null);\n    if (!parentNode) {\n      return;\n    }\n    let node = new TreeNode({scopeRef});\n    parentNode.addChild(node);\n    node.parent = parentNode;\n    this.fastMap.set(scopeRef, node);\n    if (nodeToRestore) {\n      node.nodeToRestore = nodeToRestore;\n    }\n  }\n\n  addNode(node: TreeNode) {\n    this.fastMap.set(node.scopeRef, node);\n  }\n\n  removeTreeNode(scopeRef: ScopeRef) {\n    // never remove the root\n    if (scopeRef === null) {\n      return;\n    }\n    let node = this.fastMap.get(scopeRef);\n    if (!node) {\n      return;\n    }\n    let parentNode = node.parent;\n    // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n    // if we are, then replace the siblings restore with the restore from the scope we're removing\n    for (let current of this.traverse()) {\n      if (\n        current !== node &&\n        node.nodeToRestore &&\n        current.nodeToRestore &&\n        node.scopeRef &&\n        node.scopeRef.current &&\n        isElementInScope(current.nodeToRestore, node.scopeRef.current)\n      ) {\n        current.nodeToRestore = node.nodeToRestore;\n      }\n    }\n    let children = node.children;\n    if (parentNode) {\n      parentNode.removeChild(node);\n      if (children.size > 0) {\n        children.forEach(child => parentNode && parentNode.addChild(child));\n      }\n    }\n\n    this.fastMap.delete(node.scopeRef);\n  }\n\n  // Pre Order Depth First\n  *traverse(node: TreeNode = this.root): Generator<TreeNode> {\n    if (node.scopeRef != null) {\n      yield node;\n    }\n    if (node.children.size > 0) {\n      for (let child of node.children) {\n        yield* this.traverse(child);\n      }\n    }\n  }\n\n  clone(): Tree {\n    let newTree = new Tree();\n    for (let node of this.traverse()) {\n      newTree.addTreeNode(node.scopeRef, node.parent?.scopeRef ?? null, node.nodeToRestore);\n    }\n    return newTree;\n  }\n}\n\nclass TreeNode {\n  public scopeRef: ScopeRef;\n  public nodeToRestore?: FocusableElement;\n  public parent?: TreeNode;\n  public children: Set<TreeNode> = new Set();\n  public contain = false;\n\n  constructor(props: {scopeRef: ScopeRef}) {\n    this.scopeRef = props.scopeRef;\n  }\n  addChild(node: TreeNode) {\n    this.children.add(node);\n    node.parent = this;\n  }\n  removeChild(node: TreeNode) {\n    this.children.delete(node);\n    node.parent = undefined;\n  }\n}\n\nexport let focusScopeTree = new Tree();\n"],"names":[],"version":3,"file":"FocusScope.module.js.map"}
\ No newline at end of file
+{"mappings":"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","sources":["packages/@react-aria/focus/src/FocusScope.tsx"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusSafely} from './focusSafely';\nimport {getOwnerDocument, getRootBody, getRootNode, useLayoutEffect} from '@react-aria/utils';\nimport {isElementVisible} from './isElementVisible';\nimport React, {ReactNode, RefObject, useContext, useEffect, useMemo, useRef} from 'react';\n\nexport interface FocusScopeProps {\n  /** The contents of the focus scope. */\n  children: ReactNode,\n\n  /**\n   * Whether to contain focus inside the scope, so users cannot\n   * move focus outside, for example in a modal dialog.\n   */\n  contain?: boolean,\n\n  /**\n   * Whether to restore focus back to the element that was focused\n   * when the focus scope mounted, after the focus scope unmounts.\n   */\n  restoreFocus?: boolean,\n\n  /** Whether to auto focus the first focusable element in the focus scope on mount. */\n  autoFocus?: boolean\n}\n\nexport interface FocusManagerOptions {\n  /** The element to start searching from. The currently focused element by default. */\n  from?: Element,\n  /** Whether to only include tabbable elements, or all focusable elements. */\n  tabbable?: boolean,\n  /** Whether focus should wrap around when it reaches the end of the scope. */\n  wrap?: boolean,\n  /** A callback that determines whether the given element is focused. */\n  accept?: (node: Element) => boolean\n}\n\nexport interface FocusManager {\n  /** Moves focus to the next focusable or tabbable element in the focus scope. */\n  focusNext(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the previous focusable or tabbable element in the focus scope. */\n  focusPrevious(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the first focusable or tabbable element in the focus scope. */\n  focusFirst(opts?: FocusManagerOptions): FocusableElement | null,\n  /** Moves focus to the last focusable or tabbable element in the focus scope. */\n  focusLast(opts?: FocusManagerOptions): FocusableElement | null\n}\n\ntype ScopeRef = RefObject<Element[] | null> | null;\ninterface IFocusContext {\n  focusManager: FocusManager,\n  parentNode: TreeNode | null\n}\n\nconst FocusContext = React.createContext<IFocusContext | null>(null);\nconst RESTORE_FOCUS_EVENT = 'react-aria-focus-scope-restore';\n\nlet activeScope: ScopeRef = null;\n\n// This is a hacky DOM-based implementation of a FocusScope until this RFC lands in React:\n// https://github.com/reactjs/rfcs/pull/109\n\n/**\n * A FocusScope manages focus for its descendants. It supports containing focus inside\n * the scope, restoring focus to the previously focused element on unmount, and auto\n * focusing children on mount. It also acts as a container for a programmatic focus\n * management interface that can be used to move focus forward and back in response\n * to user events.\n */\nexport function FocusScope(props: FocusScopeProps) {\n  let {children, contain, restoreFocus, autoFocus} = props;\n  let startRef = useRef<HTMLSpanElement>(null);\n  let endRef = useRef<HTMLSpanElement>(null);\n  let scopeRef = useRef<Element[]>([]);\n  let {parentNode} = useContext(FocusContext) || {};\n\n  // Create a tree node here so we can add children to it even before it is added to the tree.\n  let node = useMemo(() => new TreeNode({scopeRef}), [scopeRef]);\n\n  useLayoutEffect(() => {\n    // If a new scope mounts outside the active scope, (e.g. DialogContainer launched from a menu),\n    // use the active scope as the parent instead of the parent from context. Layout effects run bottom\n    // up, so if the parent is not yet added to the tree, don't do this. Only the outer-most FocusScope\n    // that is being added should get the activeScope as its parent.\n    let parent = parentNode || focusScopeTree.root;\n    if (focusScopeTree.getTreeNode(parent.scopeRef) && activeScope && !isAncestorScope(activeScope, parent.scopeRef)) {\n      let activeNode = focusScopeTree.getTreeNode(activeScope);\n      if (activeNode) {\n        parent = activeNode;\n      }\n    }\n\n    // Add the node to the parent, and to the tree.\n    parent.addChild(node);\n    focusScopeTree.addNode(node);\n  }, [node, parentNode]);\n\n  useLayoutEffect(() => {\n    let node = focusScopeTree.getTreeNode(scopeRef);\n    if (node) {\n      node.contain = !!contain;\n    }\n  }, [contain]);\n\n  useLayoutEffect(() => {\n    // Find all rendered nodes between the sentinels and add them to the scope.\n    let node = startRef.current?.nextSibling!;\n    let nodes: Element[] = [];\n    let stopPropagation = e => e.stopPropagation();\n    while (node && node !== endRef.current) {\n      nodes.push(node as Element);\n      // Stop custom restore focus event from propagating to parent focus scopes.\n      node.addEventListener(RESTORE_FOCUS_EVENT, stopPropagation);\n      node = node.nextSibling as Element;\n    }\n\n    scopeRef.current = nodes;\n\n    return () => {\n      for (let node of nodes) {\n        node.removeEventListener(RESTORE_FOCUS_EVENT, stopPropagation);\n      }\n    };\n  }, [children]);\n\n  useActiveScopeTracker(scopeRef, restoreFocus, contain);\n  useFocusContainment(scopeRef, contain);\n  useRestoreFocus(scopeRef, restoreFocus, contain);\n  useAutoFocus(scopeRef, autoFocus);\n\n  // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.\n  // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.\n  useEffect(() => {\n    const activeElement = getRootNode(scopeRef.current ? scopeRef.current[0] : undefined)?.activeElement;\n    let scope: TreeNode | null = null;\n\n    if (isElementInScope(activeElement, scopeRef.current)) {\n      // We need to traverse the focusScope tree and find the bottom most scope that\n      // contains the active element and set that as the activeScope.\n      for (let node of focusScopeTree.traverse()) {\n        if (node.scopeRef && isElementInScope(activeElement, node.scopeRef.current)) {\n          scope = node;\n        }\n      }\n\n      if (scope === focusScopeTree.getTreeNode(scopeRef)) {\n        activeScope = scope.scopeRef;\n      }\n    }\n  }, [scopeRef]);\n\n  // This layout effect cleanup is so that the tree node is removed synchronously with react before the RAF\n  // in useRestoreFocus cleanup runs.\n  useLayoutEffect(() => {\n    return () => {\n      // Scope may have been re-parented.\n      let parentScope = focusScopeTree.getTreeNode(scopeRef)?.parent?.scopeRef ?? null;\n\n      if (\n        (scopeRef === activeScope || isAncestorScope(scopeRef, activeScope)) &&\n        (!parentScope || focusScopeTree.getTreeNode(parentScope))\n      ) {\n        activeScope = parentScope;\n      }\n      focusScopeTree.removeTreeNode(scopeRef);\n    };\n  }, [scopeRef]);\n\n  let focusManager = useMemo(() => createFocusManagerForScope(scopeRef), []);\n  let value = useMemo(() => ({\n    focusManager,\n    parentNode: node\n  }), [node, focusManager]);\n\n  return (\n    <FocusContext.Provider value={value}>\n      <span data-focus-scope-start hidden ref={startRef} />\n      {children}\n      <span data-focus-scope-end hidden ref={endRef} />\n    </FocusContext.Provider>\n  );\n}\n\n/**\n * Returns a FocusManager interface for the parent FocusScope.\n * A FocusManager can be used to programmatically move focus within\n * a FocusScope, e.g. in response to user events like keyboard navigation.\n */\nexport function useFocusManager(): FocusManager | undefined {\n  return useContext(FocusContext)?.focusManager;\n}\n\nfunction createFocusManagerForScope(scopeRef: React.RefObject<Element[] | null>): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getRootNode(scope[0])?.activeElement!;\n      let sentinel = scope[0].previousElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = {}) {\n      let scope = scopeRef.current!;\n      let {from, tabbable, wrap, accept} = opts;\n      let node = from || getRootNode(scope[0])?.activeElement!;\n      let sentinel = scope[scope.length - 1].nextElementSibling!;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = isElementInScope(node, scope) ? node : sentinel;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = sentinel;\n        previousNode = walker.previousNode() as FocusableElement;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    },\n    focusFirst(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[0].previousElementSibling!;\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = {}) {\n      let scope = scopeRef.current!;\n      let {tabbable, accept} = opts;\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);\n      walker.currentNode = scope[scope.length - 1].nextElementSibling!;\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode;\n    }\n  };\n}\n\nconst focusableElements = [\n  'input:not([disabled]):not([type=hidden])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n  'button:not([disabled])',\n  'a[href]',\n  'area[href]',\n  'summary',\n  'iframe',\n  'object',\n  'embed',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]'\n];\n\nconst FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';\n\nfocusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\n\nexport function isFocusable(element: Element) {\n  return element.matches(FOCUSABLE_ELEMENT_SELECTOR);\n}\n\nfunction getScopeRoot(scope: Element[]) {\n  return scope[0].parentElement!;\n}\n\nfunction shouldContainFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.contain) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return true;\n}\n\nfunction useFocusContainment(scopeRef: RefObject<Element[] | null>, contain?: boolean) {\n  let focusedNode = useRef<FocusableElement>(undefined);\n\n  let raf = useRef<ReturnType<typeof requestAnimationFrame>>(undefined);\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    if (!contain) {\n      // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n        raf.current = undefined;\n      }\n      return;\n    }\n\n    const ownerDocument = getRootNode(scope ? scope[0] : undefined) || getOwnerDocument(scope ? scope[0] : undefined);\n\n    // Handle the Tab key to contain focus within the scope\n    let onKeyDown = (e) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef) || e.isComposing) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement;\n      let scope = scopeRef.current;\n      if (!scope || !isElementInScope(focusedElement, scope)) {\n        return;\n      }\n\n      let scopeRoot = getScopeRoot(scope);\n      let walker = getFocusableTreeWalker(scopeRoot, {tabbable: true}, scope);\n      if (!focusedElement) {\n        return;\n      }\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      if (!nextElement) {\n        walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling! : scope[0].previousElementSibling!;\n        nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n      }\n\n      e.preventDefault();\n      if (nextElement) {\n        focusElement(nextElement, true);\n      }\n    };\n\n    let onFocus = (e) => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) && isElementInScope(e.target, scopeRef.current)) {\n        activeScope = scopeRef;\n        focusedNode.current = e.target;\n      } else if (shouldContainFocus(scopeRef) && !isElementInChildScope(e.target, scopeRef)) {\n        // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n        // restore focus to the previously focused node or the first tabbable element in the active scope.\n        if (focusedNode.current) {\n          focusedNode.current.focus();\n        } else if (activeScope && activeScope.current) {\n          focusFirstInScope(activeScope.current);\n        }\n      } else if (shouldContainFocus(scopeRef)) {\n        focusedNode.current = e.target;\n      }\n    };\n\n    let onBlur = (e) => {\n      // Firefox doesn't shift focus back to the Dialog properly without this\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n      raf.current = requestAnimationFrame(() => {\n        // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n        if (ownerDocument.activeElement && shouldContainFocus(scopeRef) && !isElementInChildScope(ownerDocument.activeElement, scopeRef)) {\n          activeScope = scopeRef;\n          if (getRootBody(ownerDocument).contains(e.target)) {\n            focusedNode.current = e.target;\n            focusedNode.current?.focus();\n          } else if (activeScope.current) {\n            focusFirstInScope(activeScope.current);\n          }\n        }\n      });\n    };\n\n    ownerDocument.addEventListener('keydown', onKeyDown, false);\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    scope?.forEach(element => element.addEventListener('focusout', onBlur, false));\n    return () => {\n      ownerDocument.removeEventListener('keydown', onKeyDown, false);\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n      scope?.forEach(element => element.removeEventListener('focusout', onBlur, false));\n    };\n  }, [scopeRef, contain]);\n\n  // This is a useLayoutEffect so it is guaranteed to run before our async synthetic blur\n  // eslint-disable-next-line arrow-body-style\n  useLayoutEffect(() => {\n    return () => {\n      if (raf.current) {\n        cancelAnimationFrame(raf.current);\n      }\n    };\n  }, [raf]);\n}\n\nfunction isElementInAnyScope(element: Element) {\n  return isElementInChildScope(element);\n}\n\nfunction isElementInScope(element?: Element | null, scope?: Element[] | null) {\n  if (!element) {\n    return false;\n  }\n  if (!scope) {\n    return false;\n  }\n  return scope.some(node => node.contains(element));\n}\n\nfunction isElementInChildScope(element: Element, scope: ScopeRef = null) {\n  // If the element is within a top layer element (e.g. toasts), always allow moving focus there.\n  if (element instanceof Element && element.closest('[data-react-aria-top-layer]')) {\n    return true;\n  }\n\n  // node.contains in isElementInScope covers child scopes that are also DOM children,\n  // but does not cover child scopes in portals.\n  for (let {scopeRef: s} of focusScopeTree.traverse(focusScopeTree.getTreeNode(scope))) {\n    if (s && isElementInScope(element, s.current)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/** @private */\nexport function isElementInChildOfActiveScope(element: Element) {\n  return isElementInChildScope(element, activeScope);\n}\n\nfunction isAncestorScope(ancestor: ScopeRef, scope: ScopeRef) {\n  let parent = focusScopeTree.getTreeNode(scope)?.parent;\n  while (parent) {\n    if (parent.scopeRef === ancestor) {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction focusElement(element: FocusableElement | null, scroll = false) {\n  if (element != null && !scroll) {\n    try {\n      focusSafely(element);\n    } catch (err) {\n      // ignore\n    }\n  } else if (element != null) {\n    try {\n      element.focus();\n    } catch (err) {\n      // ignore\n    }\n  }\n}\n\nfunction getFirstInScope(scope: Element[], tabbable = true) {\n  let sentinel = scope[0].previousElementSibling!;\n  let scopeRoot = getScopeRoot(scope);\n  let walker = getFocusableTreeWalker(scopeRoot, {tabbable}, scope);\n  walker.currentNode = sentinel;\n  let nextNode = walker.nextNode();\n\n  // If the scope does not contain a tabbable element, use the first focusable element.\n  if (tabbable && !nextNode) {\n    scopeRoot = getScopeRoot(scope);\n    walker = getFocusableTreeWalker(scopeRoot, {tabbable: false}, scope);\n    walker.currentNode = sentinel;\n    nextNode = walker.nextNode();\n  }\n\n  return nextNode as FocusableElement;\n}\n\nfunction focusFirstInScope(scope: Element[], tabbable:boolean = true) {\n  focusElement(getFirstInScope(scope, tabbable));\n}\n\nfunction useAutoFocus(scopeRef: RefObject<Element[] | null>, autoFocus?: boolean) {\n  const autoFocusRef = React.useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      activeScope = scopeRef;\n      const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n      if (!isElementInScope(ownerDocument.activeElement, activeScope.current) && scopeRef.current) {\n        focusFirstInScope(scopeRef.current);\n      }\n    }\n    autoFocusRef.current = false;\n  }, [scopeRef]);\n}\n\nfunction useActiveScopeTracker(scopeRef: RefObject<Element[] | null>, restore?: boolean, contain?: boolean) {\n  // tracks the active scope, in case restore and contain are both false.\n  // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n  useLayoutEffect(() => {\n    if (restore || contain) {\n      return;\n    }\n\n    let scope = scopeRef.current;\n    const ownerDocument = getRootNode(scope ? scope[0] : undefined) || getOwnerDocument(scope ? scope[0] : undefined);\n\n    let onFocus = (e) => {\n      let target = e.target as Element;\n      if (isElementInScope(target, scopeRef.current)) {\n        activeScope = scopeRef;\n      } else if (!isElementInAnyScope(target)) {\n        activeScope = null;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n  }, [scopeRef, restore, contain]);\n}\n\nfunction shouldRestoreFocus(scopeRef: ScopeRef) {\n  let scope = focusScopeTree.getTreeNode(activeScope);\n  while (scope && scope.scopeRef !== scopeRef) {\n    if (scope.nodeToRestore) {\n      return false;\n    }\n\n    scope = scope.parent;\n  }\n\n  return scope?.scopeRef === scopeRef;\n}\n\nfunction useRestoreFocus(scopeRef: RefObject<Element[] | null>, restoreFocus?: boolean, contain?: boolean) {\n  // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n  // eslint-disable-next-line no-restricted-globals\n  const nodeToRestoreRef = useRef(typeof document !== 'undefined' ? getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement as FocusableElement : null);\n\n  // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n  // restoring-non-containing scopes should only care if they become active so they can perform the restore\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    const ownerDocument = getRootNode(scope ? scope[0] : undefined) || getOwnerDocument(scope ? scope[0] : undefined);\n    if (!restoreFocus || contain) {\n      return;\n    }\n\n    let onFocus = () => {\n      // If focusing an element in a child scope of the currently active scope, the child becomes active.\n      // Moving out of the active scope to an ancestor is not allowed.\n      if ((!activeScope || isAncestorScope(activeScope, scopeRef)) &&\n        isElementInScope(ownerDocument.activeElement, scopeRef.current)\n      ) {\n        activeScope = scopeRef;\n      }\n    };\n\n    ownerDocument.addEventListener('focusin', onFocus, false);\n    scope?.forEach(element => element.addEventListener('focusin', onFocus, false));\n    return () => {\n      ownerDocument.removeEventListener('focusin', onFocus, false);\n      scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [scopeRef, contain]);\n\n  useLayoutEffect(() => {\n    const ownerDocument = getRootNode(scopeRef.current ? scopeRef.current[0] : undefined) || getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    // Handle the Tab key so that tabbing out of the scope goes to the next element\n    // after the node that had focus when the scope mounted. This is important when\n    // using portals for overlays, so that focus goes to the expected element when\n    // tabbing out of the overlay.\n    let onKeyDown = (e: KeyboardEvent) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !shouldContainFocus(scopeRef) || e.isComposing) {\n        return;\n      }\n\n      let focusedElement = ownerDocument.activeElement as FocusableElement;\n      if (!isElementInScope(focusedElement, scopeRef.current)) {\n        return;\n      }\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      const rootBody = getRootBody(ownerDocument);\n\n      // Create a DOM tree walker that matches all tabbable elements\n      let walker = getFocusableTreeWalker(rootBody, {tabbable: true});\n\n      // Find the next tabbable element after the currently focused element\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n\n      if (!nodeToRestore || !rootBody.contains(nodeToRestore) || nodeToRestore === rootBody) {\n        nodeToRestore = undefined;\n        treeNode.nodeToRestore = undefined;\n      }\n\n      // If there is no next element, or it is outside the current scope, move focus to the\n      // next element after the node to restore to instead.\n      if ((!nextElement || !isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n        walker.currentNode = nodeToRestore;\n\n        // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n        do {\n          nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;\n        } while (isElementInScope(nextElement, scopeRef.current));\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (nextElement) {\n          focusElement(nextElement, true);\n        } else {\n          // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)\n          // then move focus to the body.\n          // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n          if (!isElementInAnyScope(nodeToRestore)) {\n            focusedElement.blur();\n          } else {\n            focusElement(nodeToRestore, true);\n          }\n        }\n      }\n    };\n\n    if (!contain) {\n      ownerDocument.addEventListener('keydown', onKeyDown as EventListener, true);\n    }\n\n    return () => {\n      if (!contain) {\n        ownerDocument.removeEventListener('keydown', onKeyDown as EventListener, true);\n      }\n    };\n  }, [scopeRef, restoreFocus, contain]);\n\n  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n  useLayoutEffect(() => {\n    const ownerDocument = getRootNode(scopeRef.current ? scopeRef.current[0] : undefined) || getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);\n    const rootBody = getRootBody(ownerDocument);\n\n    if (!restoreFocus) {\n      return;\n    }\n\n    let treeNode = focusScopeTree.getTreeNode(scopeRef);\n    if (!treeNode) {\n      return;\n    }\n    treeNode.nodeToRestore = nodeToRestoreRef.current ?? undefined;\n    return () => {\n      let treeNode = focusScopeTree.getTreeNode(scopeRef);\n      if (!treeNode) {\n        return;\n      }\n      let nodeToRestore = treeNode.nodeToRestore;\n\n      // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n      if (\n        restoreFocus\n        && nodeToRestore\n        && (\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          (isElementInScope(ownerDocument.activeElement, scopeRef.current) || (ownerDocument.activeElement === rootBody && shouldRestoreFocus(scopeRef)))\n        )\n      ) {\n        // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n        let clonedTree = focusScopeTree.clone();\n        requestAnimationFrame(() => {\n          // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n          if (ownerDocument.activeElement === rootBody) {\n            // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n            let treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {\n                restoreFocusToElement(treeNode.nodeToRestore);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n\n            // If no nodeToRestore was found, focus the first element in the nearest\n            // ancestor scope that is still in the tree.\n            treeNode = clonedTree.getTreeNode(scopeRef);\n            while (treeNode) {\n              if (treeNode.scopeRef && treeNode.scopeRef.current && focusScopeTree.getTreeNode(treeNode.scopeRef)) {\n                let node = getFirstInScope(treeNode.scopeRef.current, true);\n                restoreFocusToElement(node);\n                return;\n              }\n              treeNode = treeNode.parent;\n            }\n          }\n        });\n      }\n    };\n  }, [scopeRef, restoreFocus]);\n}\n\nfunction restoreFocusToElement(node: FocusableElement) {\n  // Dispatch a custom event that parent elements can intercept to customize focus restoration.\n  // For example, virtualized collection components reuse DOM elements, so the original element\n  // might still exist in the DOM but representing a different item.\n  if (node.dispatchEvent(new CustomEvent(RESTORE_FOCUS_EVENT, {bubbles: true, cancelable: true}))) {\n    focusElement(node);\n  }\n}\n\n/**\n * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}\n * that matches all focusable/tabbable elements.\n */\nexport function getFocusableTreeWalker(root: Element | ShadowRoot, opts?: FocusManagerOptions, scope?: Element[]) {\n  let selector = opts?.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;\n  let doc = root instanceof ShadowRoot ? root :  (getRootNode(root) || getOwnerDocument(root));\n  let effectiveDocument = doc instanceof ShadowRoot ? doc.ownerDocument : doc;\n  let walker = effectiveDocument.createTreeWalker(\n    root || doc,\n    NodeFilter.SHOW_ELEMENT,\n    {\n      acceptNode(node) {\n        // Skip nodes inside the starting node.\n        if (opts?.from?.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if ((node as Element).matches(selector)\n          && isElementVisible(node as Element)\n          && (!scope || isElementInScope(node as Element, scope))\n          && (!opts?.accept || opts.accept(node as Element))\n        ) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      }\n    }\n  );\n\n  if (opts?.from) {\n    walker.currentNode = opts.from;\n  }\n\n  if (doc instanceof ShadowRoot) {\n    const originalNextNode = walker.nextNode.bind(walker);\n    const originalPreviousNode = walker.previousNode.bind(walker);\n    walker.nextNode = getNextShadowNode(originalNextNode, scope);\n    walker.previousNode = getPreviousShadowNode(originalPreviousNode, scope);\n  }\n\n  return walker;\n}\n\n/**\n * Creates a FocusManager object that can be used to move focus within an element.\n */\nexport function createFocusManager(ref: RefObject<Element | null>, defaultOptions: FocusManagerOptions = {}): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || (getRootNode(root) || getOwnerDocument(root)).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      }\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (!nextNode && wrap) {\n        walker.currentNode = root;\n        nextNode = walker.nextNode() as FocusableElement;\n      }\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;\n      let node = from || (getRootNode(root) || getOwnerDocument(root)).activeElement;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      if (root.contains(node)) {\n        walker.currentNode = node!;\n      } else {\n        let next = last(walker);\n        if (next) {\n          focusElement(next, true);\n        }\n        return next ?? null;\n      }\n      let previousNode = walker.previousNode() as FocusableElement;\n      if (!previousNode && wrap) {\n        walker.currentNode = root;\n        let lastNode = last(walker);\n        if (!lastNode) {\n          // couldn't wrap\n          return null;\n        }\n        previousNode = lastNode;\n      }\n      if (previousNode) {\n        focusElement(previousNode, true);\n      }\n      return previousNode ?? null;\n    },\n    focusFirst(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let nextNode = walker.nextNode() as FocusableElement;\n      if (nextNode) {\n        focusElement(nextNode, true);\n      }\n      return nextNode;\n    },\n    focusLast(opts = defaultOptions) {\n      let root = ref.current;\n      if (!root) {\n        return null;\n      }\n      let {tabbable = defaultOptions.tabbable, accept = defaultOptions.accept} = opts;\n      let walker = getFocusableTreeWalker(root, {tabbable, accept});\n      let next = last(walker);\n      if (next) {\n        focusElement(next, true);\n      }\n      return next ?? null;\n    }\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement | undefined = undefined;\n  let last: FocusableElement;\n  do {\n    last = walker.lastChild() as FocusableElement;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n\nfunction getNextShadowNode(originalNextNode: () => Node | null, scope?: Element[]) {\n  return function () {\n    let nextElement = originalNextNode();\n    if (!nextElement && scope && scope.length > 0) {\n      let currentShadowRoot = scope[0].getRootNode();\n      let nextShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.nextElementSibling : null;\n      while (nextShadowHost) {\n        if (nextShadowHost.shadowRoot) {\n          let nextShadowScope = Array.from(nextShadowHost.shadowRoot.querySelectorAll('*')).filter(isFocusable);\n          if (nextShadowScope.length > 0) {\n            return nextShadowScope[0];\n          }\n        }\n        nextShadowHost = nextShadowHost.nextElementSibling;\n      }\n    }\n    return nextElement;\n  };\n}\n\nfunction getPreviousShadowNode(originalPreviousNode: () => Node | null, scope?: Element[]) {\n  return function () {\n    let previousElement = originalPreviousNode();\n    if (!previousElement && scope && scope.length > 0) {\n      let currentShadowRoot = scope[0].getRootNode();\n      let previousShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.previousElementSibling : null;\n      while (previousShadowHost) {\n        if (previousShadowHost.shadowRoot) {\n          let previousShadowScope = Array.from(previousShadowHost.shadowRoot.querySelectorAll('*')).filter(isFocusable);\n          if (previousShadowScope.length > 0) {\n            return previousShadowScope[previousShadowScope.length - 1];\n          }\n        }\n        previousShadowHost = previousShadowHost.previousElementSibling;\n      }\n    }\n    return previousElement;\n  };\n}\n\n\nclass Tree {\n  root: TreeNode;\n  private fastMap = new Map<ScopeRef, TreeNode>();\n\n  constructor() {\n    this.root = new TreeNode({scopeRef: null});\n    this.fastMap.set(null, this.root);\n  }\n\n  get size() {\n    return this.fastMap.size;\n  }\n\n  getTreeNode(data: ScopeRef) {\n    return this.fastMap.get(data);\n  }\n\n  addTreeNode(scopeRef: ScopeRef, parent: ScopeRef, nodeToRestore?: FocusableElement) {\n    let parentNode = this.fastMap.get(parent ?? null);\n    if (!parentNode) {\n      return;\n    }\n    let node = new TreeNode({scopeRef});\n    parentNode.addChild(node);\n    node.parent = parentNode;\n    this.fastMap.set(scopeRef, node);\n    if (nodeToRestore) {\n      node.nodeToRestore = nodeToRestore;\n    }\n  }\n\n  addNode(node: TreeNode) {\n    this.fastMap.set(node.scopeRef, node);\n  }\n\n  removeTreeNode(scopeRef: ScopeRef) {\n    // never remove the root\n    if (scopeRef === null) {\n      return;\n    }\n    let node = this.fastMap.get(scopeRef);\n    if (!node) {\n      return;\n    }\n    let parentNode = node.parent;\n    // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n    // if we are, then replace the siblings restore with the restore from the scope we're removing\n    for (let current of this.traverse()) {\n      if (\n        current !== node &&\n        node.nodeToRestore &&\n        current.nodeToRestore &&\n        node.scopeRef &&\n        node.scopeRef.current &&\n        isElementInScope(current.nodeToRestore, node.scopeRef.current)\n      ) {\n        current.nodeToRestore = node.nodeToRestore;\n      }\n    }\n    let children = node.children;\n    if (parentNode) {\n      parentNode.removeChild(node);\n      if (children.size > 0) {\n        children.forEach(child => parentNode && parentNode.addChild(child));\n      }\n    }\n\n    this.fastMap.delete(node.scopeRef);\n  }\n\n  // Pre Order Depth First\n  *traverse(node: TreeNode = this.root): Generator<TreeNode> {\n    if (node.scopeRef != null) {\n      yield node;\n    }\n    if (node.children.size > 0) {\n      for (let child of node.children) {\n        yield* this.traverse(child);\n      }\n    }\n  }\n\n  clone(): Tree {\n    let newTree = new Tree();\n    for (let node of this.traverse()) {\n      newTree.addTreeNode(node.scopeRef, node.parent?.scopeRef ?? null, node.nodeToRestore);\n    }\n    return newTree;\n  }\n}\n\nclass TreeNode {\n  public scopeRef: ScopeRef;\n  public nodeToRestore?: FocusableElement;\n  public parent?: TreeNode;\n  public children: Set<TreeNode> = new Set();\n  public contain = false;\n\n  constructor(props: {scopeRef: ScopeRef}) {\n    this.scopeRef = props.scopeRef;\n  }\n  addChild(node: TreeNode) {\n    this.children.add(node);\n    node.parent = this;\n  }\n  removeChild(node: TreeNode) {\n    this.children.delete(node);\n    node.parent = undefined;\n  }\n}\n\nexport let focusScopeTree = new Tree();\n"],"names":[],"version":3,"file":"FocusScope.module.js.map"}
\ No newline at end of file
diff --git a/dist/focusSafely.main.js b/dist/focusSafely.main.js
index f19ba477e1d2c2d72ca3cd716b00d45dcc993012..8fab199999062d8e5a53daaa7a819adaf3fbb509 100644
--- a/dist/focusSafely.main.js
+++ b/dist/focusSafely.main.js
@@ -25,12 +25,12 @@ function $1c7f9157d722357d$export$80f3e147d781571c(element) {
     // the page before shifting focus. This avoids issues with VoiceOver on iOS
     // causing the page to scroll when moving focus if the element is transitioning
     // from off the screen.
-    const ownerDocument = (0, $cBYLt$reactariautils.getOwnerDocument)(element);
+    const ownerDocument = (0, $cBYLt$reactariautils.getRootNode)(element);
     if ((0, $cBYLt$reactariainteractions.getInteractionModality)() === 'virtual') {
-        let lastFocusedElement = ownerDocument.activeElement;
+        let lastFocusedElement = ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.activeElement;
         (0, $cBYLt$reactariautils.runAfterTransition)(()=>{
             // If focus did not move and the element is still in the document, focus it.
-            if (ownerDocument.activeElement === lastFocusedElement && element.isConnected) (0, $cBYLt$reactariautils.focusWithoutScrolling)(element);
+            if ((ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.activeElement) === lastFocusedElement && element.isConnected) (0, $cBYLt$reactariautils.focusWithoutScrolling)(element);
         });
     } else (0, $cBYLt$reactariautils.focusWithoutScrolling)(element);
 }
diff --git a/dist/focusSafely.main.js.map b/dist/focusSafely.main.js.map
index d8517c52e4f8ad80750de11fe9ad8086601e27cf..195617742ee84cd62b3c5518eb73762799a8a05e 100644
--- a/dist/focusSafely.main.js.map
+++ b/dist/focusSafely.main.js.map
@@ -1 +1 @@
-{"mappings":";;;;;;;;;AAAA;;;;;;;;;;CAUC;;AAUM,SAAS,0CAAY,OAAyB;IACnD,6EAA6E;IAC7E,4EAA4E;IAC5E,2EAA2E;IAC3E,+EAA+E;IAC/E,uBAAuB;IACvB,MAAM,gBAAgB,CAAA,GAAA,sCAAe,EAAE;IACvC,IAAI,CAAA,GAAA,mDAAqB,QAAQ,WAAW;QAC1C,IAAI,qBAAqB,cAAc,aAAa;QACpD,CAAA,GAAA,wCAAiB,EAAE;YACjB,4EAA4E;YAC5E,IAAI,cAAc,aAAa,KAAK,sBAAsB,QAAQ,WAAW,EAC3E,CAAA,GAAA,2CAAoB,EAAE;QAE1B;IACF,OACE,CAAA,GAAA,2CAAoB,EAAE;AAE1B","sources":["packages/@react-aria/focus/src/focusSafely.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusWithoutScrolling, getOwnerDocument, runAfterTransition} from '@react-aria/utils';\nimport {getInteractionModality} from '@react-aria/interactions';\n\n/**\n * A utility function that focuses an element while avoiding undesired side effects such\n * as page scrolling and screen reader issues with CSS transitions.\n */\nexport function focusSafely(element: FocusableElement) {\n  // If the user is interacting with a virtual cursor, e.g. screen reader, then\n  // wait until after any animated transitions that are currently occurring on\n  // the page before shifting focus. This avoids issues with VoiceOver on iOS\n  // causing the page to scroll when moving focus if the element is transitioning\n  // from off the screen.\n  const ownerDocument = getOwnerDocument(element);\n  if (getInteractionModality() === 'virtual') {\n    let lastFocusedElement = ownerDocument.activeElement;\n    runAfterTransition(() => {\n      // If focus did not move and the element is still in the document, focus it.\n      if (ownerDocument.activeElement === lastFocusedElement && element.isConnected) {\n        focusWithoutScrolling(element);\n      }\n    });\n  } else {\n    focusWithoutScrolling(element);\n  }\n}\n"],"names":[],"version":3,"file":"focusSafely.main.js.map"}
\ No newline at end of file
+{"mappings":";;;;;;;;;AAAA;;;;;;;;;;CAUC;;AAUM,SAAS,0CAAY,OAAyB;IACnD,6EAA6E;IAC7E,4EAA4E;IAC5E,2EAA2E;IAC3E,+EAA+E;IAC/E,uBAAuB;IACvB,MAAM,gBAAgB,CAAA,GAAA,iCAAU,EAAE;IAClC,IAAI,CAAA,GAAA,mDAAqB,QAAQ,WAAW;QAC1C,IAAI,qBAAqB,0BAAA,oCAAA,cAAe,aAAa;QACrD,CAAA,GAAA,wCAAiB,EAAE;YACjB,4EAA4E;YAC5E,IAAI,CAAA,0BAAA,oCAAA,cAAe,aAAa,MAAK,sBAAsB,QAAQ,WAAW,EAC5E,CAAA,GAAA,2CAAoB,EAAE;QAE1B;IACF,OACE,CAAA,GAAA,2CAAoB,EAAE;AAE1B","sources":["packages/@react-aria/focus/src/focusSafely.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusWithoutScrolling, getRootNode, runAfterTransition} from '@react-aria/utils';\nimport {getInteractionModality} from '@react-aria/interactions';\n\n/**\n * A utility function that focuses an element while avoiding undesired side effects such\n * as page scrolling and screen reader issues with CSS transitions.\n */\nexport function focusSafely(element: FocusableElement) {\n  // If the user is interacting with a virtual cursor, e.g. screen reader, then\n  // wait until after any animated transitions that are currently occurring on\n  // the page before shifting focus. This avoids issues with VoiceOver on iOS\n  // causing the page to scroll when moving focus if the element is transitioning\n  // from off the screen.\n  const ownerDocument = getRootNode(element);\n  if (getInteractionModality() === 'virtual') {\n    let lastFocusedElement = ownerDocument?.activeElement;\n    runAfterTransition(() => {\n      // If focus did not move and the element is still in the document, focus it.\n      if (ownerDocument?.activeElement === lastFocusedElement && element.isConnected) {\n        focusWithoutScrolling(element);\n      }\n    });\n  } else {\n    focusWithoutScrolling(element);\n  }\n}\n"],"names":[],"version":3,"file":"focusSafely.main.js.map"}
\ No newline at end of file
diff --git a/dist/focusSafely.mjs b/dist/focusSafely.mjs
index 9c3118b356daa90d4dd5b21fdb28f07f907e7501..4b9b4b8b43b4a214aafb25e5dbbed2c909a3622a 100644
--- a/dist/focusSafely.mjs
+++ b/dist/focusSafely.mjs
@@ -1,4 +1,4 @@
-import {getOwnerDocument as $jlOai$getOwnerDocument, runAfterTransition as $jlOai$runAfterTransition, focusWithoutScrolling as $jlOai$focusWithoutScrolling} from "@react-aria/utils";
+import {getRootNode as $jlOai$getRootNode, runAfterTransition as $jlOai$runAfterTransition, focusWithoutScrolling as $jlOai$focusWithoutScrolling} from "@react-aria/utils";
 import {getInteractionModality as $jlOai$getInteractionModality} from "@react-aria/interactions";
 
 /*
@@ -19,12 +19,12 @@ function $6a99195332edec8b$export$80f3e147d781571c(element) {
     // the page before shifting focus. This avoids issues with VoiceOver on iOS
     // causing the page to scroll when moving focus if the element is transitioning
     // from off the screen.
-    const ownerDocument = (0, $jlOai$getOwnerDocument)(element);
+    const ownerDocument = (0, $jlOai$getRootNode)(element);
     if ((0, $jlOai$getInteractionModality)() === 'virtual') {
-        let lastFocusedElement = ownerDocument.activeElement;
+        let lastFocusedElement = ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.activeElement;
         (0, $jlOai$runAfterTransition)(()=>{
             // If focus did not move and the element is still in the document, focus it.
-            if (ownerDocument.activeElement === lastFocusedElement && element.isConnected) (0, $jlOai$focusWithoutScrolling)(element);
+            if ((ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.activeElement) === lastFocusedElement && element.isConnected) (0, $jlOai$focusWithoutScrolling)(element);
         });
     } else (0, $jlOai$focusWithoutScrolling)(element);
 }
diff --git a/dist/focusSafely.module.js b/dist/focusSafely.module.js
index 9c3118b356daa90d4dd5b21fdb28f07f907e7501..4b9b4b8b43b4a214aafb25e5dbbed2c909a3622a 100644
--- a/dist/focusSafely.module.js
+++ b/dist/focusSafely.module.js
@@ -1,4 +1,4 @@
-import {getOwnerDocument as $jlOai$getOwnerDocument, runAfterTransition as $jlOai$runAfterTransition, focusWithoutScrolling as $jlOai$focusWithoutScrolling} from "@react-aria/utils";
+import {getRootNode as $jlOai$getRootNode, runAfterTransition as $jlOai$runAfterTransition, focusWithoutScrolling as $jlOai$focusWithoutScrolling} from "@react-aria/utils";
 import {getInteractionModality as $jlOai$getInteractionModality} from "@react-aria/interactions";
 
 /*
@@ -19,12 +19,12 @@ function $6a99195332edec8b$export$80f3e147d781571c(element) {
     // the page before shifting focus. This avoids issues with VoiceOver on iOS
     // causing the page to scroll when moving focus if the element is transitioning
     // from off the screen.
-    const ownerDocument = (0, $jlOai$getOwnerDocument)(element);
+    const ownerDocument = (0, $jlOai$getRootNode)(element);
     if ((0, $jlOai$getInteractionModality)() === 'virtual') {
-        let lastFocusedElement = ownerDocument.activeElement;
+        let lastFocusedElement = ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.activeElement;
         (0, $jlOai$runAfterTransition)(()=>{
             // If focus did not move and the element is still in the document, focus it.
-            if (ownerDocument.activeElement === lastFocusedElement && element.isConnected) (0, $jlOai$focusWithoutScrolling)(element);
+            if ((ownerDocument === null || ownerDocument === void 0 ? void 0 : ownerDocument.activeElement) === lastFocusedElement && element.isConnected) (0, $jlOai$focusWithoutScrolling)(element);
         });
     } else (0, $jlOai$focusWithoutScrolling)(element);
 }
diff --git a/dist/focusSafely.module.js.map b/dist/focusSafely.module.js.map
index 08dcc97bf925f1c78f4cdf579e7a48243a324884..f17a8ed8639fae3c2324b2c92c72100c92483b5b 100644
--- a/dist/focusSafely.module.js.map
+++ b/dist/focusSafely.module.js.map
@@ -1 +1 @@
-{"mappings":";;;AAAA;;;;;;;;;;CAUC;;AAUM,SAAS,0CAAY,OAAyB;IACnD,6EAA6E;IAC7E,4EAA4E;IAC5E,2EAA2E;IAC3E,+EAA+E;IAC/E,uBAAuB;IACvB,MAAM,gBAAgB,CAAA,GAAA,uBAAe,EAAE;IACvC,IAAI,CAAA,GAAA,6BAAqB,QAAQ,WAAW;QAC1C,IAAI,qBAAqB,cAAc,aAAa;QACpD,CAAA,GAAA,yBAAiB,EAAE;YACjB,4EAA4E;YAC5E,IAAI,cAAc,aAAa,KAAK,sBAAsB,QAAQ,WAAW,EAC3E,CAAA,GAAA,4BAAoB,EAAE;QAE1B;IACF,OACE,CAAA,GAAA,4BAAoB,EAAE;AAE1B","sources":["packages/@react-aria/focus/src/focusSafely.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusWithoutScrolling, getOwnerDocument, runAfterTransition} from '@react-aria/utils';\nimport {getInteractionModality} from '@react-aria/interactions';\n\n/**\n * A utility function that focuses an element while avoiding undesired side effects such\n * as page scrolling and screen reader issues with CSS transitions.\n */\nexport function focusSafely(element: FocusableElement) {\n  // If the user is interacting with a virtual cursor, e.g. screen reader, then\n  // wait until after any animated transitions that are currently occurring on\n  // the page before shifting focus. This avoids issues with VoiceOver on iOS\n  // causing the page to scroll when moving focus if the element is transitioning\n  // from off the screen.\n  const ownerDocument = getOwnerDocument(element);\n  if (getInteractionModality() === 'virtual') {\n    let lastFocusedElement = ownerDocument.activeElement;\n    runAfterTransition(() => {\n      // If focus did not move and the element is still in the document, focus it.\n      if (ownerDocument.activeElement === lastFocusedElement && element.isConnected) {\n        focusWithoutScrolling(element);\n      }\n    });\n  } else {\n    focusWithoutScrolling(element);\n  }\n}\n"],"names":[],"version":3,"file":"focusSafely.module.js.map"}
\ No newline at end of file
+{"mappings":";;;AAAA;;;;;;;;;;CAUC;;AAUM,SAAS,0CAAY,OAAyB;IACnD,6EAA6E;IAC7E,4EAA4E;IAC5E,2EAA2E;IAC3E,+EAA+E;IAC/E,uBAAuB;IACvB,MAAM,gBAAgB,CAAA,GAAA,kBAAU,EAAE;IAClC,IAAI,CAAA,GAAA,6BAAqB,QAAQ,WAAW;QAC1C,IAAI,qBAAqB,0BAAA,oCAAA,cAAe,aAAa;QACrD,CAAA,GAAA,yBAAiB,EAAE;YACjB,4EAA4E;YAC5E,IAAI,CAAA,0BAAA,oCAAA,cAAe,aAAa,MAAK,sBAAsB,QAAQ,WAAW,EAC5E,CAAA,GAAA,4BAAoB,EAAE;QAE1B;IACF,OACE,CAAA,GAAA,4BAAoB,EAAE;AAE1B","sources":["packages/@react-aria/focus/src/focusSafely.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport {focusWithoutScrolling, getRootNode, runAfterTransition} from '@react-aria/utils';\nimport {getInteractionModality} from '@react-aria/interactions';\n\n/**\n * A utility function that focuses an element while avoiding undesired side effects such\n * as page scrolling and screen reader issues with CSS transitions.\n */\nexport function focusSafely(element: FocusableElement) {\n  // If the user is interacting with a virtual cursor, e.g. screen reader, then\n  // wait until after any animated transitions that are currently occurring on\n  // the page before shifting focus. This avoids issues with VoiceOver on iOS\n  // causing the page to scroll when moving focus if the element is transitioning\n  // from off the screen.\n  const ownerDocument = getRootNode(element);\n  if (getInteractionModality() === 'virtual') {\n    let lastFocusedElement = ownerDocument?.activeElement;\n    runAfterTransition(() => {\n      // If focus did not move and the element is still in the document, focus it.\n      if (ownerDocument?.activeElement === lastFocusedElement && element.isConnected) {\n        focusWithoutScrolling(element);\n      }\n    });\n  } else {\n    focusWithoutScrolling(element);\n  }\n}\n"],"names":[],"version":3,"file":"focusSafely.module.js.map"}
\ No newline at end of file
diff --git a/dist/types.d.ts b/dist/types.d.ts
index 72693652c8b1245715b0624ec3f3cfd458f9b2a2..b9606561bc1a6b782ab22054669439d976d1010f 100644
--- a/dist/types.d.ts
+++ b/dist/types.d.ts
@@ -55,18 +55,18 @@ export function FocusScope(props: FocusScopeProps): React.JSX.Element;
  * a FocusScope, e.g. in response to user events like keyboard navigation.
  */
 export function useFocusManager(): FocusManager | undefined;
-export function isFocusable(element: HTMLElement): boolean;
+export function isFocusable(element: Element): boolean;
 /** @private */
 export function isElementInChildOfActiveScope(element: Element): boolean;
 /**
  * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}
  * that matches all focusable/tabbable elements.
  */
-export function getFocusableTreeWalker(root: Element, opts?: FocusManagerOptions, scope?: Element[]): TreeWalker;
+export function getFocusableTreeWalker(root: Element | ShadowRoot, opts?: FocusManagerOptions, scope?: Element[]): TreeWalker;
 /**
  * Creates a FocusManager object that can be used to move focus within an element.
  */
-export function createFocusManager(ref: RefObject<Element>, defaultOptions?: FocusManagerOptions): FocusManager;
+export function createFocusManager(ref: RefObject<Element | null>, defaultOptions?: FocusManagerOptions): FocusManager;
 export interface AriaFocusRingProps {
     /**
      * Whether to show the focus ring when something
diff --git a/dist/types.d.ts.map b/dist/types.d.ts.map
index cef734d1f4b62c3036739e85330a5a732cf8f3e0..b87ee4835b4992e75da218e813663b85f41e1433 100644
--- a/dist/types.d.ts.map
+++ b/dist/types.d.ts.map
@@ -1 +1 @@
-{"mappings":"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","sources":["packages/@react-aria/focus/src/packages/@react-aria/focus/src/focusSafely.ts","packages/@react-aria/focus/src/packages/@react-aria/focus/src/isElementVisible.ts","packages/@react-aria/focus/src/packages/@react-aria/focus/src/FocusScope.tsx","packages/@react-aria/focus/src/packages/@react-aria/focus/src/useFocusRing.ts","packages/@react-aria/focus/src/packages/@react-aria/focus/src/FocusRing.tsx","packages/@react-aria/focus/src/packages/@react-aria/focus/src/useFocusable.tsx","packages/@react-aria/focus/src/packages/@react-aria/focus/src/useHasTabbableChild.ts","packages/@react-aria/focus/src/packages/@react-aria/focus/src/index.ts","packages/@react-aria/focus/src/index.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {FocusScope, useFocusManager, getFocusableTreeWalker, createFocusManager, isElementInChildOfActiveScope, isFocusable} from './FocusScope';\nexport {FocusRing} from './FocusRing';\nexport {FocusableProvider, useFocusable} from './useFocusable';\nexport {useFocusRing} from './useFocusRing';\nexport {focusSafely} from './focusSafely';\nexport {useHasTabbableChild} from './useHasTabbableChild';\n\nexport type {FocusScopeProps, FocusManager, FocusManagerOptions} from './FocusScope';\nexport type {FocusRingProps} from './FocusRing';\nexport type {FocusableAria, FocusableOptions, FocusableProviderProps} from './useFocusable';\nexport type {AriaFocusRingProps, FocusRingAria} from './useFocusRing';\n"],"names":[],"version":3,"file":"types.d.ts.map"}
\ No newline at end of file
+{"mappings":"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","sources":["packages/@react-aria/focus/src/packages/@react-aria/focus/src/focusSafely.ts","packages/@react-aria/focus/src/packages/@react-aria/focus/src/isElementVisible.ts","packages/@react-aria/focus/src/packages/@react-aria/focus/src/FocusScope.tsx","packages/@react-aria/focus/src/packages/@react-aria/focus/src/useFocusRing.ts","packages/@react-aria/focus/src/packages/@react-aria/focus/src/FocusRing.tsx","packages/@react-aria/focus/src/packages/@react-aria/focus/src/useFocusable.tsx","packages/@react-aria/focus/src/packages/@react-aria/focus/src/useHasTabbableChild.ts","packages/@react-aria/focus/src/packages/@react-aria/focus/src/index.ts","packages/@react-aria/focus/src/index.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {FocusScope, useFocusManager, getFocusableTreeWalker, createFocusManager, isElementInChildOfActiveScope, isFocusable} from './FocusScope';\nexport {FocusRing} from './FocusRing';\nexport {FocusableProvider, useFocusable} from './useFocusable';\nexport {useFocusRing} from './useFocusRing';\nexport {focusSafely} from './focusSafely';\nexport {useHasTabbableChild} from './useHasTabbableChild';\n\nexport type {FocusScopeProps, FocusManager, FocusManagerOptions} from './FocusScope';\nexport type {FocusRingProps} from './FocusRing';\nexport type {FocusableAria, FocusableOptions, FocusableProviderProps} from './useFocusable';\nexport type {AriaFocusRingProps, FocusRingAria} from './useFocusRing';\n"],"names":[],"version":3,"file":"types.d.ts.map"}
\ No newline at end of file
diff --git a/src/FocusScope.tsx b/src/FocusScope.tsx
index 44809030abf0cf8bd0d48b788cd1432019c4993b..c270ee3de0403cfde584e7e1c09304de8d8e5882 100644
--- a/src/FocusScope.tsx
+++ b/src/FocusScope.tsx
@@ -12,7 +12,7 @@
 
 import {FocusableElement} from '@react-types/shared';
 import {focusSafely} from './focusSafely';
-import {getOwnerDocument, useLayoutEffect} from '@react-aria/utils';
+import {getOwnerDocument, getRootBody, getRootNode, useLayoutEffect} from '@react-aria/utils';
 import {isElementVisible} from './isElementVisible';
 import React, {ReactNode, RefObject, useContext, useEffect, useMemo, useRef} from 'react';
 
@@ -54,17 +54,18 @@ export interface FocusManager {
   focusPrevious(opts?: FocusManagerOptions): FocusableElement | null,
   /** Moves focus to the first focusable or tabbable element in the focus scope. */
   focusFirst(opts?: FocusManagerOptions): FocusableElement | null,
-    /** Moves focus to the last focusable or tabbable element in the focus scope. */
+  /** Moves focus to the last focusable or tabbable element in the focus scope. */
   focusLast(opts?: FocusManagerOptions): FocusableElement | null
 }
 
-type ScopeRef = RefObject<Element[]> | null;
+type ScopeRef = RefObject<Element[] | null> | null;
 interface IFocusContext {
   focusManager: FocusManager,
   parentNode: TreeNode | null
 }
 
 const FocusContext = React.createContext<IFocusContext | null>(null);
+const RESTORE_FOCUS_EVENT = 'react-aria-focus-scope-restore';
 
 let activeScope: ScopeRef = null;
 
@@ -117,12 +118,21 @@ export function FocusScope(props: FocusScopeProps) {
     // Find all rendered nodes between the sentinels and add them to the scope.
     let node = startRef.current?.nextSibling!;
     let nodes: Element[] = [];
+    let stopPropagation = e => e.stopPropagation();
     while (node && node !== endRef.current) {
       nodes.push(node as Element);
+      // Stop custom restore focus event from propagating to parent focus scopes.
+      node.addEventListener(RESTORE_FOCUS_EVENT, stopPropagation);
       node = node.nextSibling as Element;
     }
 
     scopeRef.current = nodes;
+
+    return () => {
+      for (let node of nodes) {
+        node.removeEventListener(RESTORE_FOCUS_EVENT, stopPropagation);
+      }
+    };
   }, [children]);
 
   useActiveScopeTracker(scopeRef, restoreFocus, contain);
@@ -133,7 +143,7 @@ export function FocusScope(props: FocusScopeProps) {
   // This needs to be an effect so that activeScope is updated after the FocusScope tree is complete.
   // It cannot be a useLayoutEffect because the parent of this node hasn't been attached in the tree yet.
   useEffect(() => {
-    const activeElement = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement;
+    const activeElement = getRootNode(scopeRef.current ? scopeRef.current[0] : undefined)?.activeElement;
     let scope: TreeNode | null = null;
 
     if (isElementInScope(activeElement, scopeRef.current)) {
@@ -159,8 +169,8 @@ export function FocusScope(props: FocusScopeProps) {
       let parentScope = focusScopeTree.getTreeNode(scopeRef)?.parent?.scopeRef ?? null;
 
       if (
-        (scopeRef === activeScope || isAncestorScope(scopeRef, activeScope)) &&
-        (!parentScope || focusScopeTree.getTreeNode(parentScope))
+          (scopeRef === activeScope || isAncestorScope(scopeRef, activeScope)) &&
+          (!parentScope || focusScopeTree.getTreeNode(parentScope))
       ) {
         activeScope = parentScope;
       }
@@ -175,11 +185,11 @@ export function FocusScope(props: FocusScopeProps) {
   }), [node, focusManager]);
 
   return (
-    <FocusContext.Provider value={value}>
-      <span data-focus-scope-start hidden ref={startRef} />
-      {children}
-      <span data-focus-scope-end hidden ref={endRef} />
-    </FocusContext.Provider>
+      <FocusContext.Provider value={value}>
+        <span data-focus-scope-start hidden ref={startRef} />
+        {children}
+        <span data-focus-scope-end hidden ref={endRef} />
+      </FocusContext.Provider>
   );
 }
 
@@ -192,12 +202,12 @@ export function useFocusManager(): FocusManager | undefined {
   return useContext(FocusContext)?.focusManager;
 }
 
-function createFocusManagerForScope(scopeRef: React.RefObject<Element[]>): FocusManager {
+function createFocusManagerForScope(scopeRef: React.RefObject<Element[] | null>): FocusManager {
   return {
     focusNext(opts: FocusManagerOptions = {}) {
       let scope = scopeRef.current!;
       let {from, tabbable, wrap, accept} = opts;
-      let node = from || getOwnerDocument(scope[0]).activeElement!;
+      let node = from || getRootNode(scope[0])?.activeElement!;
       let sentinel = scope[0].previousElementSibling!;
       let scopeRoot = getScopeRoot(scope);
       let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);
@@ -215,7 +225,7 @@ function createFocusManagerForScope(scopeRef: React.RefObject<Element[]>): Focus
     focusPrevious(opts: FocusManagerOptions = {}) {
       let scope = scopeRef.current!;
       let {from, tabbable, wrap, accept} = opts;
-      let node = from || getOwnerDocument(scope[0]).activeElement!;
+      let node = from || getRootNode(scope[0])?.activeElement!;
       let sentinel = scope[scope.length - 1].nextElementSibling!;
       let scopeRoot = getScopeRoot(scope);
       let walker = getFocusableTreeWalker(scopeRoot, {tabbable, accept}, scope);
@@ -278,7 +288,7 @@ const FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]),') + '
 focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
 const TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([hidden]):not([tabindex="-1"]),');
 
-export function isFocusable(element: HTMLElement) {
+export function isFocusable(element: Element) {
   return element.matches(FOCUSABLE_ELEMENT_SELECTOR);
 }
 
@@ -299,10 +309,10 @@ function shouldContainFocus(scopeRef: ScopeRef) {
   return true;
 }
 
-function useFocusContainment(scopeRef: RefObject<Element[]>, contain?: boolean) {
-  let focusedNode = useRef<FocusableElement>();
+function useFocusContainment(scopeRef: RefObject<Element[] | null>, contain?: boolean) {
+  let focusedNode = useRef<FocusableElement>(undefined);
 
-  let raf = useRef<ReturnType<typeof requestAnimationFrame>>();
+  let raf = useRef<ReturnType<typeof requestAnimationFrame>>(undefined);
   useLayoutEffect(() => {
     let scope = scopeRef.current;
     if (!contain) {
@@ -314,7 +324,7 @@ function useFocusContainment(scopeRef: RefObject<Element[]>, contain?: boolean)
       return;
     }
 
-    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);
+    const ownerDocument = getRootNode(scope ? scope[0] : undefined) || getOwnerDocument(scope ? scope[0] : undefined);
 
     // Handle the Tab key to contain focus within the scope
     let onKeyDown = (e) => {
@@ -374,7 +384,7 @@ function useFocusContainment(scopeRef: RefObject<Element[]>, contain?: boolean)
         // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe
         if (ownerDocument.activeElement && shouldContainFocus(scopeRef) && !isElementInChildScope(ownerDocument.activeElement, scopeRef)) {
           activeScope = scopeRef;
-          if (ownerDocument.body.contains(e.target)) {
+          if (getRootBody(ownerDocument).contains(e.target)) {
             focusedNode.current = e.target;
             focusedNode.current?.focus();
           } else if (activeScope.current) {
@@ -470,7 +480,7 @@ function focusElement(element: FocusableElement | null, scroll = false) {
   }
 }
 
-function focusFirstInScope(scope: Element[], tabbable:boolean = true) {
+function getFirstInScope(scope: Element[], tabbable = true) {
   let sentinel = scope[0].previousElementSibling!;
   let scopeRoot = getScopeRoot(scope);
   let walker = getFocusableTreeWalker(scopeRoot, {tabbable}, scope);
@@ -485,10 +495,14 @@ function focusFirstInScope(scope: Element[], tabbable:boolean = true) {
     nextNode = walker.nextNode();
   }
 
-  focusElement(nextNode as FocusableElement);
+  return nextNode as FocusableElement;
 }
 
-function useAutoFocus(scopeRef: RefObject<Element[]>, autoFocus?: boolean) {
+function focusFirstInScope(scope: Element[], tabbable:boolean = true) {
+  focusElement(getFirstInScope(scope, tabbable));
+}
+
+function useAutoFocus(scopeRef: RefObject<Element[] | null>, autoFocus?: boolean) {
   const autoFocusRef = React.useRef(autoFocus);
   useEffect(() => {
     if (autoFocusRef.current) {
@@ -502,7 +516,7 @@ function useAutoFocus(scopeRef: RefObject<Element[]>, autoFocus?: boolean) {
   }, [scopeRef]);
 }
 
-function useActiveScopeTracker(scopeRef: RefObject<Element[]>, restore?: boolean, contain?: boolean) {
+function useActiveScopeTracker(scopeRef: RefObject<Element[] | null>, restore?: boolean, contain?: boolean) {
   // tracks the active scope, in case restore and contain are both false.
   // if either are true, this is tracked in useRestoreFocus or useFocusContainment.
   useLayoutEffect(() => {
@@ -511,7 +525,7 @@ function useActiveScopeTracker(scopeRef: RefObject<Element[]>, restore?: boolean
     }
 
     let scope = scopeRef.current;
-    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);
+    const ownerDocument = getRootNode(scope ? scope[0] : undefined) || getOwnerDocument(scope ? scope[0] : undefined);
 
     let onFocus = (e) => {
       let target = e.target as Element;
@@ -544,7 +558,7 @@ function shouldRestoreFocus(scopeRef: ScopeRef) {
   return scope?.scopeRef === scopeRef;
 }
 
-function useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean, contain?: boolean) {
+function useRestoreFocus(scopeRef: RefObject<Element[] | null>, restoreFocus?: boolean, contain?: boolean) {
   // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.
   // eslint-disable-next-line no-restricted-globals
   const nodeToRestoreRef = useRef(typeof document !== 'undefined' ? getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined).activeElement as FocusableElement : null);
@@ -553,7 +567,7 @@ function useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean,
   // restoring-non-containing scopes should only care if they become active so they can perform the restore
   useLayoutEffect(() => {
     let scope = scopeRef.current;
-    const ownerDocument = getOwnerDocument(scope ? scope[0] : undefined);
+    const ownerDocument = getRootNode(scope ? scope[0] : undefined) || getOwnerDocument(scope ? scope[0] : undefined);
     if (!restoreFocus || contain) {
       return;
     }
@@ -562,7 +576,7 @@ function useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean,
       // If focusing an element in a child scope of the currently active scope, the child becomes active.
       // Moving out of the active scope to an ancestor is not allowed.
       if ((!activeScope || isAncestorScope(activeScope, scopeRef)) &&
-      isElementInScope(ownerDocument.activeElement, scopeRef.current)
+          isElementInScope(ownerDocument.activeElement, scopeRef.current)
       ) {
         activeScope = scopeRef;
       }
@@ -574,11 +588,11 @@ function useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean,
       ownerDocument.removeEventListener('focusin', onFocus, false);
       scope?.forEach(element => element.removeEventListener('focusin', onFocus, false));
     };
-  // eslint-disable-next-line react-hooks/exhaustive-deps
+    // eslint-disable-next-line react-hooks/exhaustive-deps
   }, [scopeRef, contain]);
 
   useLayoutEffect(() => {
-    const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);
+    const ownerDocument = getRootNode(scopeRef.current ? scopeRef.current[0] : undefined) || getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);
 
     if (!restoreFocus) {
       return;
@@ -603,14 +617,16 @@ function useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean,
       }
       let nodeToRestore = treeNode.nodeToRestore;
 
+      const rootBody = getRootBody(ownerDocument);
+
       // Create a DOM tree walker that matches all tabbable elements
-      let walker = getFocusableTreeWalker(ownerDocument.body, {tabbable: true});
+      let walker = getFocusableTreeWalker(rootBody, {tabbable: true});
 
       // Find the next tabbable element after the currently focused element
       walker.currentNode = focusedElement;
       let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as FocusableElement;
 
-      if (!nodeToRestore || !ownerDocument.body.contains(nodeToRestore) || nodeToRestore === ownerDocument.body) {
+      if (!nodeToRestore || !rootBody.contains(nodeToRestore) || nodeToRestore === rootBody) {
         nodeToRestore = undefined;
         treeNode.nodeToRestore = undefined;
       }
@@ -630,9 +646,9 @@ function useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean,
         if (nextElement) {
           focusElement(nextElement, true);
         } else {
-           // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
-           // then move focus to the body.
-           // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
+          // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)
+          // then move focus to the body.
+          // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)
           if (!isElementInAnyScope(nodeToRestore)) {
             focusedElement.blur();
           } else {
@@ -643,19 +659,20 @@ function useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean,
     };
 
     if (!contain) {
-      ownerDocument.addEventListener('keydown', onKeyDown, true);
+      ownerDocument.addEventListener('keydown', onKeyDown as EventListener, true);
     }
 
     return () => {
       if (!contain) {
-        ownerDocument.removeEventListener('keydown', onKeyDown, true);
+        ownerDocument.removeEventListener('keydown', onKeyDown as EventListener, true);
       }
     };
   }, [scopeRef, restoreFocus, contain]);
 
   // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.
   useLayoutEffect(() => {
-    const ownerDocument = getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);
+    const ownerDocument = getRootNode(scopeRef.current ? scopeRef.current[0] : undefined) || getOwnerDocument(scopeRef.current ? scopeRef.current[0] : undefined);
+    const rootBody = getRootBody(ownerDocument);
 
     if (!restoreFocus) {
       return;
@@ -675,24 +692,23 @@ function useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean,
 
       // if we already lost focus to the body and this was the active scope, then we should attempt to restore
       if (
-        restoreFocus
-        && nodeToRestore
-        && (
-          // eslint-disable-next-line react-hooks/exhaustive-deps
-          isElementInScope(ownerDocument.activeElement, scopeRef.current)
-          || (ownerDocument.activeElement === ownerDocument.body && shouldRestoreFocus(scopeRef))
-        )
+          restoreFocus
+          && nodeToRestore
+          && (
+              // eslint-disable-next-line react-hooks/exhaustive-deps
+              (isElementInScope(ownerDocument.activeElement, scopeRef.current) || (ownerDocument.activeElement === rootBody && shouldRestoreFocus(scopeRef)))
+          )
       ) {
         // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it
         let clonedTree = focusScopeTree.clone();
         requestAnimationFrame(() => {
           // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere
-          if (ownerDocument.activeElement === ownerDocument.body) {
+          if (ownerDocument.activeElement === rootBody) {
             // look up the tree starting with our scope to find a nodeToRestore still in the DOM
             let treeNode = clonedTree.getTreeNode(scopeRef);
             while (treeNode) {
               if (treeNode.nodeToRestore && treeNode.nodeToRestore.isConnected) {
-                focusElement(treeNode.nodeToRestore);
+                restoreFocusToElement(treeNode.nodeToRestore);
                 return;
               }
               treeNode = treeNode.parent;
@@ -703,7 +719,8 @@ function useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean,
             treeNode = clonedTree.getTreeNode(scopeRef);
             while (treeNode) {
               if (treeNode.scopeRef && treeNode.scopeRef.current && focusScopeTree.getTreeNode(treeNode.scopeRef)) {
-                focusFirstInScope(treeNode.scopeRef.current, true);
+                let node = getFirstInScope(treeNode.scopeRef.current, true);
+                restoreFocusToElement(node);
                 return;
               }
               treeNode = treeNode.parent;
@@ -715,46 +732,64 @@ function useRestoreFocus(scopeRef: RefObject<Element[]>, restoreFocus?: boolean,
   }, [scopeRef, restoreFocus]);
 }
 
+function restoreFocusToElement(node: FocusableElement) {
+  // Dispatch a custom event that parent elements can intercept to customize focus restoration.
+  // For example, virtualized collection components reuse DOM elements, so the original element
+  // might still exist in the DOM but representing a different item.
+  if (node.dispatchEvent(new CustomEvent(RESTORE_FOCUS_EVENT, {bubbles: true, cancelable: true}))) {
+    focusElement(node);
+  }
+}
+
 /**
  * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}
  * that matches all focusable/tabbable elements.
  */
-export function getFocusableTreeWalker(root: Element, opts?: FocusManagerOptions, scope?: Element[]) {
+export function getFocusableTreeWalker(root: Element | ShadowRoot, opts?: FocusManagerOptions, scope?: Element[]) {
   let selector = opts?.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;
-  let walker = getOwnerDocument(root).createTreeWalker(
-    root,
-    NodeFilter.SHOW_ELEMENT,
-    {
-      acceptNode(node) {
-        // Skip nodes inside the starting node.
-        if (opts?.from?.contains(node)) {
-          return NodeFilter.FILTER_REJECT;
-        }
+  let doc = root instanceof ShadowRoot ? root :  (getRootNode(root) || getOwnerDocument(root));
+  let effectiveDocument = doc instanceof ShadowRoot ? doc.ownerDocument : doc;
+  let walker = effectiveDocument.createTreeWalker(
+      root || doc,
+      NodeFilter.SHOW_ELEMENT,
+      {
+        acceptNode(node) {
+          // Skip nodes inside the starting node.
+          if (opts?.from?.contains(node)) {
+            return NodeFilter.FILTER_REJECT;
+          }
 
-        if ((node as Element).matches(selector)
-          && isElementVisible(node as Element)
-          && (!scope || isElementInScope(node as Element, scope))
-          && (!opts?.accept || opts.accept(node as Element))
-        ) {
-          return NodeFilter.FILTER_ACCEPT;
-        }
+          if ((node as Element).matches(selector)
+              && isElementVisible(node as Element)
+              && (!scope || isElementInScope(node as Element, scope))
+              && (!opts?.accept || opts.accept(node as Element))
+          ) {
+            return NodeFilter.FILTER_ACCEPT;
+          }
 
-        return NodeFilter.FILTER_SKIP;
+          return NodeFilter.FILTER_SKIP;
+        }
       }
-    }
   );
 
   if (opts?.from) {
     walker.currentNode = opts.from;
   }
 
+  if (doc instanceof ShadowRoot) {
+    const originalNextNode = walker.nextNode.bind(walker);
+    const originalPreviousNode = walker.previousNode.bind(walker);
+    walker.nextNode = getNextShadowNode(originalNextNode, scope);
+    walker.previousNode = getPreviousShadowNode(originalPreviousNode, scope);
+  }
+
   return walker;
 }
 
 /**
  * Creates a FocusManager object that can be used to move focus within an element.
  */
-export function createFocusManager(ref: RefObject<Element>, defaultOptions: FocusManagerOptions = {}): FocusManager {
+export function createFocusManager(ref: RefObject<Element | null>, defaultOptions: FocusManagerOptions = {}): FocusManager {
   return {
     focusNext(opts: FocusManagerOptions = {}) {
       let root = ref.current;
@@ -762,7 +797,7 @@ export function createFocusManager(ref: RefObject<Element>, defaultOptions: Focu
         return null;
       }
       let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;
-      let node = from || getOwnerDocument(root).activeElement;
+      let node = from || (getRootNode(root) || getOwnerDocument(root)).activeElement;
       let walker = getFocusableTreeWalker(root, {tabbable, accept});
       if (root.contains(node)) {
         walker.currentNode = node!;
@@ -783,7 +818,7 @@ export function createFocusManager(ref: RefObject<Element>, defaultOptions: Focu
         return null;
       }
       let {from, tabbable = defaultOptions.tabbable, wrap = defaultOptions.wrap, accept = defaultOptions.accept} = opts;
-      let node = from || getOwnerDocument(root).activeElement;
+      let node = from || (getRootNode(root) || getOwnerDocument(root)).activeElement;
       let walker = getFocusableTreeWalker(root, {tabbable, accept});
       if (root.contains(node)) {
         walker.currentNode = node!;
@@ -850,6 +885,46 @@ function last(walker: TreeWalker) {
   return next;
 }
 
+function getNextShadowNode(originalNextNode: () => Node | null, scope?: Element[]) {
+  return function () {
+    let nextElement = originalNextNode();
+    if (!nextElement && scope && scope.length > 0) {
+      let currentShadowRoot = scope[0].getRootNode();
+      let nextShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.nextElementSibling : null;
+      while (nextShadowHost) {
+        if (nextShadowHost.shadowRoot) {
+          let nextShadowScope = Array.from(nextShadowHost.shadowRoot.querySelectorAll('*')).filter(isFocusable);
+          if (nextShadowScope.length > 0) {
+            return nextShadowScope[0];
+          }
+        }
+        nextShadowHost = nextShadowHost.nextElementSibling;
+      }
+    }
+    return nextElement;
+  };
+}
+
+function getPreviousShadowNode(originalPreviousNode: () => Node | null, scope?: Element[]) {
+  return function () {
+    let previousElement = originalPreviousNode();
+    if (!previousElement && scope && scope.length > 0) {
+      let currentShadowRoot = scope[0].getRootNode();
+      let previousShadowHost = currentShadowRoot instanceof ShadowRoot ? currentShadowRoot.host.previousElementSibling : null;
+      while (previousShadowHost) {
+        if (previousShadowHost.shadowRoot) {
+          let previousShadowScope = Array.from(previousShadowHost.shadowRoot.querySelectorAll('*')).filter(isFocusable);
+          if (previousShadowScope.length > 0) {
+            return previousShadowScope[previousShadowScope.length - 1];
+          }
+        }
+        previousShadowHost = previousShadowHost.previousElementSibling;
+      }
+    }
+    return previousElement;
+  };
+}
+
 
 class Tree {
   root: TreeNode;
@@ -900,12 +975,12 @@ class Tree {
     // if we are, then replace the siblings restore with the restore from the scope we're removing
     for (let current of this.traverse()) {
       if (
-        current !== node &&
-        node.nodeToRestore &&
-        current.nodeToRestore &&
-        node.scopeRef &&
-        node.scopeRef.current &&
-        isElementInScope(current.nodeToRestore, node.scopeRef.current)
+          current !== node &&
+          node.nodeToRestore &&
+          current.nodeToRestore &&
+          node.scopeRef &&
+          node.scopeRef.current &&
+          isElementInScope(current.nodeToRestore, node.scopeRef.current)
       ) {
         current.nodeToRestore = node.nodeToRestore;
       }
diff --git a/src/focusSafely.ts b/src/focusSafely.ts
index e0bc52e94650c0c9a3d0fadcdb4141864eb9ce3a..2fb91ce0fd823db69d6e89c2380af29eed875767 100644
--- a/src/focusSafely.ts
+++ b/src/focusSafely.ts
@@ -11,7 +11,7 @@
  */
 
 import {FocusableElement} from '@react-types/shared';
-import {focusWithoutScrolling, getOwnerDocument, runAfterTransition} from '@react-aria/utils';
+import {focusWithoutScrolling, getRootNode, runAfterTransition} from '@react-aria/utils';
 import {getInteractionModality} from '@react-aria/interactions';
 
 /**
@@ -24,12 +24,12 @@ export function focusSafely(element: FocusableElement) {
   // the page before shifting focus. This avoids issues with VoiceOver on iOS
   // causing the page to scroll when moving focus if the element is transitioning
   // from off the screen.
-  const ownerDocument = getOwnerDocument(element);
+  const ownerDocument = getRootNode(element);
   if (getInteractionModality() === 'virtual') {
-    let lastFocusedElement = ownerDocument.activeElement;
+    let lastFocusedElement = ownerDocument?.activeElement;
     runAfterTransition(() => {
       // If focus did not move and the element is still in the document, focus it.
-      if (ownerDocument.activeElement === lastFocusedElement && element.isConnected) {
+      if (ownerDocument?.activeElement === lastFocusedElement && element.isConnected) {
         focusWithoutScrolling(element);
       }
     });
